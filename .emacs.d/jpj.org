* env.el

i use a separate file to manage sensitive variables i can't commit to version
control. that's =env.el= with the following variables set:
- gptel-claude-3-api-key
- gptel-api-key-alist
- spotify-client-id
- spotify-client-secret

* freeish keybindings

- C-q (never used)
- C-[ (unused)

* basic emacs

** keymap fns

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/lisp")
(require 'keymap)
#+END_SRC

#+RESULTS:
: keymap

** no debug

#+BEGIN_SRC emacs-lisp
(setq debug-on-error nil)
#+END_SRC

#+RESULTS:

** suppress warnings

#+BEGIN_SRC emacs-lisp
(setq warning-minimum-level :error)
#+END_SRC

#+RESULTS:
: :error

** startup

suppress noise on start up

#+BEGIN_SRC emacs-lisp
(setq-default inhibit-startup-screen t
              inhibit-splash-screen t
              initial-scratch-message "")
#+END_SRC

#+RESULTS:

** fullscreen

#+BEGIN_SRC emacs-lisp
(defun toggle-fullscreen ()
  "Toggle full screen on Emacs mac."
  (interactive)
  (set-frame-parameter
   nil 'fullscreen
   (when (not (frame-parameter nil 'fullscreen)) 'fullscreen)))

(global-set-key [f11] 'toggle-fullscreen) ; Bind F11 key to toggle fullscreen

(toggle-fullscreen)
#+END_SRC

#+RESULTS:

** clipboard

this command makes sure that OS X clipboard is saved to the kill-ring in the
case that you kill something within emacs.

#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC

** put custom-set variables in =custom.el=, not =init.el=
#+BEGIN_SRC emacs-lisp
;; File for custom-set variables
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

#+RESULTS:
: t

** open specific files

#+BEGIN_SRC emacs-lisp
(defun jpj ()
  (interactive)
  (find-file "~/.emacs.d/jpj.org")
  )

(defun open-macos-setup ()
  (interactive)
  (find-file "~/code/jpjagt/dotfiles/macos_setup.org")
  )
#+END_SRC

#+RESULTS:
: open-macos-setup

** random

fix mac meta keys

#+BEGIN_SRC emacs-lisp
(setq mac-option-key-is-meta nil
      mac-command-key-is-meta t
      mac-command-modifier 'meta
      mac-option-modifier 'super)
#+END_SRC

#+RESULTS:
: super

disable that big old yellow triangle in the center of the screen:

#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC

#+RESULTS:
: t

typing =C-n= on last line will create a newline:

#+BEGIN_SRC emacs-lisp
(setq next-line-add-newlines t)
#+END_SRC

#+RESULTS:
: t

be able to dynamically create functions:

#+BEGIN_SRC emacs-lisp
(defun define-named-lambda (name lambd args)
  (defalias (intern name) `(lambda () (interactive) (apply ,lambd ',args))))

(defun define-custom-function (name func)
  (define-named-lambda name (lambda () (funcall func))))
#+END_SRC

#+RESULTS:
: define-custom-function

** basic keybindings

*** backspace

i don't like having to move my hands so much for backspace. so, following
https://www.emacswiki.org/emacs/BackspaceKey:

#+BEGIN_SRC emacs-lisp
(define-key key-translation-map [?\C-?] [?\C-h])
(bind-key* "C-ч" 'org-delete-backward-char)

;; map M-backspace [backward-kill-word] to M-h
(define-key key-translation-map [?\M-\d] [?\M-h])

;; map C-h to backspace
(define-key key-translation-map [?\C-h] [?\C-?])

;; map M-h [mark-paragraph] to M-backspace
(define-key key-translation-map [?\M-h] [?\M-\d])

;; tip: Tab is available as C-i
;;      RET is available as C-j or C-m
;;      ESC is available as C-[
#+END_SRC

#+RESULTS:
: [134217855]

*** other

#+BEGIN_SRC emacs-lisp
(bind-key* "s-s" 'shell)
(bind-key* "s-u"  'revert-buffer)
(bind-key* "C-c j"  'join-line)

;; buffer management
(global-set-key (kbd "C-c b") 'bury-buffer)
(global-set-key (kbd "C-x C-b") 'ibuffer)

;; zoom in/out
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)

(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c C-c") 'eval-buffer)))
nil
#+END_SRC

#+RESULTS:
: join-line

*** mongolian keyboard

#+BEGIN_SRC emacs-lisp
(defun insert-mongolian-alternative-y ()
  (interactive)
  (insert "ү"))

(defun insert-mongolian-capital-alternative-y ()
  (interactive)
  (insert "Ү"))

(defun insert-mongolian-alternative-o ()
  (interactive)
  (insert "ө"))

(defun insert-mongolian-capital-alternative-o ()
  (interactive)
  (insert "Ө"))

(bind-key* "s-у" 'insert-mongolian-alternative-y)
(bind-key* "s-У" 'insert-mongolian-capital-alternative-y)
(bind-key* "s-о" 'insert-mongolian-alternative-o)
(bind-key* "s-О" 'insert-mongolian-capital-alternative-o)
#+END_SRC

#+RESULTS:
: insert-mongolian-capital-alternative-o

** set/pop marks for navigation

apparently, transient-mark-mode is AWESOME but it can ruin the alternative use
of marks a little bit: saving positions quickly. so we bind keys for that.

from https://www.masteringemacs.org/article/fixing-mark-commands-transient-mark-mode

#+BEGIN_SRC emacs-lisp
(defun push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
   Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))

(global-set-key (kbd "C-`") 'push-mark-no-activate)

(defun jump-to-mark ()
  "Jumps to the local mark, respecting the `mark-ring' order.
  This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))
(global-set-key (kbd "s-`") 'jump-to-mark)

;; (defun exchange-point-and-mark-no-activate ()
;;   "Identical to \\[exchange-point-and-mark] but will not activate the region."
;;   (interactive)
;;   (exchange-point-and-mark)
;;   (deactivate-mark nil))
;; (define-key global-map [remap exchange-point-and-mark] 'exchange-point-and-mark-no-activate)
#+END_SRC

#+RESULTS:
: jump-to-mark

** unfill paragraph/region
#+BEGIN_SRC emacs-lisp
;;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and makes it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
        ;; This would override `fill-column' if it's an integer.
        (emacs-lisp-docstring-fill-column t))
    (fill-paragraph nil region)))

(defun unfill-region ()
  (interactive)
  (let ((fill-column (point-max)))
    (fill-region (region-beginning) (region-end) nil)))

(defun copy-unfilled-region ()
  "Copy the region to a temporary buffer, unfill each line from bottom to top, then copy back to the kill-ring."
  (interactive)
  (when (use-region-p)  ; Ensure there is an active region
    (let ((region-text (buffer-substring-no-properties (region-beginning) (region-end))))
      (with-temp-buffer
        (org-mode)
        (insert region-text)
        (goto-char (point-max))  ; Start from the end of the buffer
        (while (> (point) (point-min))
          (unfill-paragraph)  ; Call your unfill-paragraph function
          (forward-line -1))  ; Move up one line
        (kill-new (buffer-string)))  ; Copy the result to the kill-ring
      (deactivate-mark)
      (message "Region unfilled and copied"))))

(global-set-key "\C-ceu" 'unfill-paragraph)
#+END_SRC

#+RESULTS:
: unfill-paragraph

** kill-word

=M-backspace= not only deletes the previous word, but also copies it, which I
think is pretty annoying. Let's change this behaviour. The function called when
hitting =M-backspace= is =backward-kill-word=.

This is defined in simple.el, and it calls =kill-word=. Let's define a function
called delete-word, which

#+BEGIN_SRC emacs-lisp
(defun delete-word (arg)
  "Delete characters forward until encountering the end of a word.
With argument ARG, do this that many times."
  (interactive "p")
  (delete-region (point) (progn (forward-word arg) (point))))

(defun backward-delete-word (arg)
  "Delete characters backward until encountering the beginning of a word.
With argument ARG, do this that many times."
  (interactive "p")
  (delete-word (- arg)))

(global-set-key (kbd "M-<backspace>") `backward-delete-word)
#+END_SRC

#+RESULTS:
: backward-delete-word

#+BEGIN_SRC emacs-lisp
(defun kill-word (arg)
  "Kill characters forward until encountering the end of a word.
With argument ARG, do this that many times."
  (interactive "p")
  (delete-region (point) (progn (forward-word arg) (point))))
#+END_SRC

#+RESULTS:
: kill-word

** global text scale / font size

#+BEGIN_SRC emacs-lisp
(define-globalized-minor-mode
  global-text-scale-mode
  text-scale-mode
  (lambda () (text-scale-mode 1)))

(defun global-text-scale-adjust (inc) (interactive)
       (text-scale-set 1)
       (kill-local-variable 'text-scale-mode-amount)
       (setq-default text-scale-mode-amount (+ text-scale-mode-amount inc))
       (global-text-scale-mode 1)
       )

(defun global-text-scale-increase () (interactive)
       (global-text-scale-adjust 1))

(defun global-text-scale-decrease () (interactive)
       (global-text-scale-adjust -1))

(defun global-text-scale-reset () (interactive)
       (global-text-scale-adjust (- text-scale-mode-amount))
       (global-text-scale-mode -1))


;; increase default text scale by one
(global-text-scale-increase)

(bind-keys*
 ("C-x C-M-=" . global-text-scale-increase)
 ("C-x C-M--" . global-text-scale-decrease)
 ("C-x C-M-0" . global-text-scale-reset)
 )
#+END_SRC

#+RESULTS:
: global-text-scale-reset

** [paul] removing brackets around region

Taken from https://emacs.stackexchange.com/questions/10786/remove-parentheses-around-region

#+BEGIN_SRC emacs-lisp
(defun my-delete-surrounded-delimiters ()
  (interactive)
  ;; save where region begins & ends
  (let ((beginning (region-beginning))
        (end (region-end)))
        (save-excursion
        (goto-char end)
        (delete-char -1)
        (goto-char beginning)
        (delete-char 1))))

(defun my-move-region-inwards ()
   (interactive)
   ;; save where region begins & ends
   (let ((beginning (region-beginning))
         (end (region-end)))
     (progn
       (exchange-point-and-mark)
       (backward-char)
       (exchange-point-and-mark)
       (forward-char))))

(global-set-key (kbd "C-M-<backspace>") `my-delete-surrounded-delimiters)
(global-set-key (kbd "C-M-r") `my-move-region-inwards)
#+END_SRC

#+RESULTS:
: my-move-region-inwards

** UTF-8 / BOM encoding

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(setq-default buffer-file-coding-system 'utf-8-unix)
#+END_SRC

#+RESULTS:
: utf-8-unix

* env

load API keys and potentially other configurations:

#+BEGIN_SRC emacs-lisp
(load-file "~/.emacs.d/env.el")
#+END_SRC

* vital functions/libraries

** s (string manipulation)

#+BEGIN_SRC emacs-lisp
(use-package s
  :straight t)
#+END_SRC

#+RESULTS:
: s

** dash (list manipulation)

#+BEGIN_SRC emacs-lisp
(use-package dash
  :straight t)
#+END_SRC

#+RESULTS:

** crux

crux are a set of useful basic utility functions. here's an overview pulled
from its README:

| Command                                             | Suggested Keybinding(s) | Description                                                                |
|-----------------------------------------------------+-------------------------+----------------------------------------------------------------------------|
| `crux-open-with`                                    | C-c o                   | Open the currently visited file with an external program.                  |
| `crux-smart-kill-line`                              | C-k or Super-k          | First kill to end of line, then kill the whole line.                       |
| `crux-smart-open-line-above`                        | C-S-RET or Super-o      | Insert an empty line above the current line and indent it properly.        |
| `crux-smart-open-line`                              | S-RET or M-o            | Insert an empty line and indent it properly (as in most IDEs).             |
| `crux-cleanup-buffer-or-region`                     | C-c n                   | Fix indentation in buffer and strip whitespace.                            |
| `crux-recentf-find-file`                            | C-c f or Super-r        | Open recently visited file.                                                |
| `crux-recentf-find-directory`                       | C-c F                   | Open recently visited directory.                                           |
| `crux-view-url`                                     | C-c u                   | Open a new buffer containing the contents of URL.                          |
| `crux-eval-and-replace`                             | C-c e                   | Eval a bit of Emacs Lisp code and replace it with its result.              |
| `crux-transpose-windows`                            | C-x 4 t                 | Transpose the buffers between two windows.                                 |
| `crux-delete-file-and-buffer`                       | C-c D                   | Delete current file and buffer.                                            |
| `crux-copy-file-preserve-attributes`                | C-c c                   | Copy current file with file attributes preserved                           |
| `crux-duplicate-current-line-or-region`             | C-c d                   | Duplicate the current line (or region).                                    |
| `crux-duplicate-and-comment-current-line-or-region` | C-c M-d                 | Duplicate and comment the current line (or region).                        |
| `crux-rename-file-and-buffer`                       | C-c r                   | Rename the current buffer and its visiting file if any.                    |
| `crux-visit-term-buffer`                            | C-c t                   | Open a terminal emulator (`ansi-term`).                                    |
| `crux-kill-other-buffers`                           | C-c k                   | Kill all open buffers except the one you're currently in.                  |
| `crux-indent-defun`                                 | C-M z                   | Indent the definition at point.                                            |
| `crux-indent-rigidly-and-copy-to-clipboard`         | C-c TAB                 | Indent and copy region to clipboard                                        |
| `crux-find-user-init-file`                          | C-c I                   | Open user's init file.                                                     |
| `crux-find-user-custom-file`                        | C-c ,                   | Open user's custom file.                                                   |
| `crux-find-shell-init-file`                         | C-c S                   | Open shell's init file.                                                    |
| `crux-top-join-line`                                | Super-j or C-^          | Join lines                                                                 |
| `crux-kill-whole-line`                              | Super-k                 | Kill whole line                                                            |
| `crux-kill-line-backwards`                          | C-Backspace             | Kill line backwards                                                        |
| `crux-kill-and-join-forward`                        | C-S-Backspace or C-k    | If at end of line, join with following; otherwise kill line.               |
| `crux-kill-buffer-truename `                        | C-c P                   | Kill absolute path of file visited in current buffer.                      |
| `crux-ispell-word-then-abbrev`                      | C-c i                   | Fix word using `ispell` and then save to `abbrev`.                         |
| `crux-upcase-region`                                | C-x C-u                 | `upcase-region` when `transient-mark-mode` is on and region is active.     |
| `crux-downcase-region`                              | C-x C-l                 | `downcase-region` when `transient-mark-mode` is on and region is active.   |
| `crux-capitalize-region`                            | C-x M-c                 | `capitalize-region` when `transient-mark-mode` is on and region is active. |
| `crux-other-window-or-switch-buffer`                | M-o                     | Select other window, or switch to most recent buffer if only one windows.  |

#+BEGIN_SRC emacs-lisp
;; (defun get-crux-key (key)
;;   (s-join " " (list "C-c r" key)))

(use-package crux
  :straight t
  :bind (
         ("C-c r C-o" . crux-open-with)
         ("C-k" . crux-smart-kill-line)
         ("C-c r o" . crux-smart-open-line-above)
         ;; ("C-c r ?" . crux-smart-open-line)
         ;; ("C-c r ?" . crux-cleanup-buffer-or-region)
         ;; ("C-c r ?" . crux-recentf-find-file)
         ;; ("C-c r ?" . crux-recentf-find-directory)
         ;; ("C-c r ?" . crux-view-url)
         ("C-c r e" . crux-eval-and-replace)
         ("C-c r t" . crux-transpose-windows)
         ("C-c r C-d" . crux-delete-file-and-buffer)
         ;; ("C-c r ?" . crux-copy-file-preserve-attributes)
         ("C-c d" . crux-duplicate-current-line-or-region)
         ("C-c M-d" . crux-duplicate-and-comment-current-line-or-region)
         ("C-c r C-r" . crux-rename-file-and-buffer)
         ;; ("C-c r ?" . crux-visit-term-buffer)
         ;; ("C-c r ?" . crux-kill-other-buffers)
         ;; ("C-c r ?" . crux-indent-defun)
         ("C-c r TAB" . crux-indent-rigidly-and-copy-to-clipboard)
         ;; ("C-c r ?" . crux-find-user-init-file)
         ;; ("C-c r ?" . crux-find-user-custom-file)
         ;; ("C-c r ?" . crux-find-shell-init-file)
         ("C-c r j" . crux-top-join-line)
         ;; ("C-c r ?" . crux-kill-whole-line)
         ;; ("C-c r ?" . crux-kill-line-backwards)
         ;; ("C-c r ?" . crux-kill-and-join-forward)
         ("C-c r p" . crux-kill-buffer-truename)
         ;; ("C-c r ?" . crux-ispell-word-then-abbrev)
         ("C-c r u" . crux-upcase-region)
         ("C-c r d" . crux-downcase-region)
         ("C-c r c" . crux-capitalize-region)
         ;; ("C-c r ?" . crux-other-window-or-switch-buffer)
         ))
#+END_SRC

#+RESULTS:
: crux-capitalize-region

importantly, crux also provides some augmentations to existing commands
(below is adapted from its README):

*** crux-with-region-or-buffer

You can use `crux-with-region-or-buffer` to make a command acting
normally on a region to operate on the entire buffer in the absence of
a region. Here are a few examples you can stuff in your config:

=(crux-with-region-or-buffer indent-region)=

*** crux-with-region-or-line

Likewise, you can use `crux-with-region-or-line` to make a command
alternately act on the current line if the mark is not active:

=(crux-with-region-or-line comment-or-uncomment-region)=

*** crux-with-region-or-point-to-eol

Sometimes you might want to act on the point until the end of the
current line, rather than the whole line, in the absence of a region:

=(crux-with-region-or-point-to-eol kill-ring-save)=

** jpj fns

*** find-and-replace-in-git-repo

#+BEGIN_SRC emacs-lisp
(defun find-and-replace-in-git-repo ()
  "Find and replace old with new in current git repo"
  (interactive)
  (let* ((old (read-string "old:"))
         (new (read-string "new:"))
         (cmd
          (s-join ""
                  (list
                   "~/.virtualenvs/base/bin/pdfx -v '"
                   old
                   "' | sed -n 's/" old "/" new "/p'"))))
    (shell-command cmd buffer)
    (switch-to-buffer buffer)))
;; git grep -l '.apply(' | xargs sed -i '' 's/.apply/.swifter.apply/g'
#+END_SRC

** ace-window

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t)
(global-set-key (kbd "M-o") 'ace-window)
(setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
(defvar aw-dispatch-alist
  '((?x aw-delete-window "Delete Window")
  (?m aw-swap-window "Swap Windows")
  (?M aw-move-window "Move Window")
  (?c aw-copy-window "Copy Window")
  (?j aw-switch-buffer-in-window "Select Buffer")
  (?n aw-flip-window)
  (?u aw-switch-buffer-other-window "Switch Buffer Other Window")
  (?c aw-split-window-fair "Split Fair Window")
  (?v aw-split-window-vert "Split Vert Window")
  (?b aw-split-window-horz "Split Horz Window")
  (?o delete-other-windows "Delete Other Windows")
  (?? aw-show-dispatch-help))
  "List of actions for `aw-dispatch-default'.")
#+END_SRC

#+RESULTS:
: aw-dispatch-alist

** copy fpath/fname to clipboard

Taken from https://stackoverflow.com/questions/2416655/file-path-to-clipboard-in-emacs

#+BEGIN_SRC emacs-lisp
(defun remove-ssh-prefix (filename)
    "Removes ssh-prefix of filenames taken from remote locations"
    (first (last (split-string filename ":")))
    )

(defun get-current-fpath ()
  (let* ((filename-raw (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name)))
         (filename (if (string-prefix-p "/ssh:" filename-raw) (remove-ssh-prefix filename-raw) filename-raw)))
    filename))

(defun cpath ()
  "Copy the current buffer full path to the clipboard."
  (interactive)
  (let* ((filename (get-current-fpath)))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))


(defun cdir ()
  "Copy the current buffer full path to the clipboard."
  (interactive)
  (let* ((filename-raw (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name)))
         (filename (file-name-directory (if (string-prefix-p "/ssh:" filename-raw) (remove-ssh-prefix filename-raw) filename-raw))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))

(defun cfile ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let* ((filepath-raw (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name)))
         (filename (file-name-nondirectory filepath-raw)))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))

(defun cname ()
  (interactive)
  (cfile))
#+END_SRC

#+RESULTS:
: cfile

** meow (modal editing)

#+BEGIN_SRC emacs-lisp
(defun meow-setup ()
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
  (meow-motion-overwrite-define-key
   '("j" . meow-next)
   '("k" . meow-prev)
   '("<escape>" . ignore))
  (meow-leader-define-key
   ;; SPC j/k will run the original command in MOTION state.
   '("j" . "H-j")
   '("k" . "H-k")
   ;; Use SPC (0-9) for digit arguments.
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("/" . meow-keypad-describe-key)
   '("?" . meow-cheatsheet))
  (meow-normal-define-key
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("6" . meow-expand-6)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)
   '("-" . negative-argument)
   '(";" . meow-reverse)
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("[" . meow-beginning-of-thing)
   '("]" . meow-end-of-thing)
   '("a" . meow-append)
   '("A" . meow-open-below)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("c" . meow-change)
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("f" . meow-find)
   '("g" . meow-cancel-selection)
   '("G" . meow-grab)
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("j" . meow-next)
   '("J" . meow-next-expand)
   '("k" . meow-prev)
   '("K" . meow-prev-expand)
   '("l" . meow-right)
   '("L" . meow-right-expand)
   '("m" . meow-join)
   '("n" . meow-search)
   '("o" . meow-block)
   '("O" . meow-to-block)
   '("p" . meow-yank)
   '("q" . meow-quit)
   '("Q" . meow-goto-line)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("s" . meow-kill)
   '("t" . meow-till)
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)
   '("v" . meow-visit)
   '("w" . meow-mark-word)
   '("W" . meow-mark-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-save)
   '("Y" . meow-sync-grab)
   '("z" . meow-pop-selection)
   '("'" . repeat)
   '("<escape>" . ignore)
   '("C-q" . ignore)))

(use-package meow
  :straight t
  :init
  ;; (meow-setup)
  ;; (meow-define-keys 'insert
  ;;  '("C-q" . meow-insert-exit))
  ;; (meow-global-mode 1)
  )
#+END_SRC

#+RESULTS:

** gpg-agent stuff

#+BEGIN_SRC emacs-lisp
  (use-package pinentry
        :straight t)

  (setq epa-pinentry-mode 'loopback)
  (pinentry-start)
#+END_SRC

#+RESULTS:
| :server-file | /var/folders/97/htw849gj5bq8x8l5306kmdfm0000gn/T/emacs501/pinentry |

* compat

#+BEGIN_SRC emacs-lisp
(use-package compat
  :straight t
  :config
  (require 'compat)
)
#+END_SRC

* appearance
** font lock
#+BEGIN_SRC emacs-lisp
  ;; Enable pretty syntax highlighting everywhere
  (global-font-lock-mode t)
#+END_SRC

** whitespace
#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :ensure t
  :init (setq-default indicate-empty-lines t)
  :config
  (setq whitespace-line-column nil
        whitespace-style '(face trailing lines-tail empty
                                indentation::space space-before-tab::tab))
  (global-whitespace-mode -1))

(setq-default indent-tabs-mode nil)

(defcustom do-whitespace-cleanup t
  "Perform whitespace-cleanup on save."
  :group 'whitespace)

(make-variable-buffer-local 'do-whitespace-cleanup)

(defun toggle-whitespace-cleanup ()
  "Turn the whitespace-cleanup hook on and off."
  (interactive)
  (setq do-whitespace-cleanup (not do-whitespace-cleanup))
  (message "do-whitespace-cleanup set to %s" do-whitespace-cleanup))

(add-hook 'before-save-hook
          (lambda ()
            (when do-whitespace-cleanup
              (whitespace-cleanup))))

(add-hook 'makefile-mode-hook
          (lambda ()
            (setq indent-tabs-mode t
                  do-whitespace-cleanup nil)))

;; (add-hook 'prog-mode-hook
;;           (lambda ()
;;             (whitespace-mode +1)
;;             ;; (setq show-trailing-whitespace t)
;;             ))
#+END_SRC

#+RESULTS:
| lambda | nil | (whitespace-mode 1) |

** font
- [[https://www.emacswiki.org/emacs/SetFonts][Setting fonts]]
- See also ~/tmp/prettify-utils.el

** Decorations
Turn off all windows decoration.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode 0)
(menu-bar-mode 0)
(scroll-all-mode 0)
(scroll-bar-mode 0)
(tooltip-mode )

#+END_SRC

#+RESULTS:
: t

** theming

themes i like:
| doom-laserwave |
| doom-palenight |
| doom-moonlight |

** doom-palenight

#+BEGIN_SRC emacs-lisp
;;; doom-palenight-theme.el --- inspired by Material-PaleNight -*- no-byte-compile: t; -*-
(add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
(use-package doom-themes
  :ensure t
  :config (load-theme 'doom-palenight t)

  ;; Enable flashing mode-line on errors
  (doom-themes-visual-bell-config)

  ;; Corrects (and improves) org-mode's native fontification.
  (doom-themes-org-config))
#+END_SRC

#+RESULTS:
: t

** flexoki

#+BEGIN_SRC emacs-lisp
(use-package flexoki-themes
  :straight t
  :custom
  (flexoki-themes-use-bold-keywords t)
  (flexoki-themes-use-bold-builtins t)
  (flexoki-themes-use-italic-comments t))
#+END_SRC

#+RESULTS:

** my theming

#+BEGIN_SRC emacs-lisp
(defun load-theme-and-disable-all-others (theme)
  ;; (load-theme theme t)
  (mapc (lambda (th) (unless (eq th theme) (disable-theme th)))
        custom-enabled-themes)
  (load-theme theme t)
  )

(defun light ()
  (interactive)
  (load-theme-and-disable-all-others 'flexoki-themes-light))

(defun gray ()
  (interactive)
  (load-theme-and-disable-all-others 'doom-nova))

(defun dark ()
  (interactive)
  (load-theme-and-disable-all-others 'doom-palenight))

(defun darker ()
  (interactive)
  (load-theme-and-disable-all-others 'flexoki-themes-dark))

(dark)
#+END_SRC

#+RESULTS:
: t


** additional theming

change active region highlighting

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'region nil :background (doom-darken "#c792ea" 0.6) :foreground nil) ;; "#ffffff")
#+END_SRC

#+RESULTS:

disable/enable horizontal line where point is

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 0)
(set-face-background 'hl-line (doom-darken "#c792ea" 0.77))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
;; (add-to-list 'load-path "~/.emacs.d/repos/elegant-emacs")
;; (require 'sanity)
;; ;; (require 'elegance)

(setq my-font "DM Mono 13")

;; alternatively:

;; (setq my-font "Roboto Mono 13")

(set-face-font 'default my-font)

(set-fontset-font
 "fontset-default" 'han
 (font-spec :family "Noto Sans Mono CJK SC"))

;; ;; (set-frame-parameter (selected-frame)
;; ;;                      'internal-border-width 24)
(setq default-frame-alist
      (append (list '(vertical-scroll-bars . nil)
                    ;; '(internal-border-width . 24)
                    '(font . "DM Mono 13"))))


;; ;; Line spacing, can be 0 for code and 1 or 2 for text
;; (setq-default line-spacing 0)

;; ;; Underline line at descent position, not baseline position
;; (setq x-underline-at-descent-line t)

;; ;; No ugly button for checkboxes
;; (setq widget-image-enable nil)

;; ;; No sound
;; (setq visible-bell t)
;; (setq ring-bell-function 'ignore)

;; ;; Paren mode is part of the theme
;; (show-paren-mode t)

;; ;; this is a purposefully long line that I hope will show some things in the fringe
;; ;; (fringe-mode '(10 . 10))
;; (defface fallback '((t :family "Fira Code Light"
;;                        :inherit 'face-faded)) "Fallback")
;; (set-display-table-slot standard-display-table 'truncation
;;                         (make-glyph-code ?… 'fallback))
;; (set-display-table-slot standard-display-table 'wrap
;;                         (make-glyph-code ?↩ 'fallback))

;; ;; Vertical window divider
;; (setq window-divider-default-right-width 3)
;; (setq window-divider-default-places 'right-only)
;; (window-divider-mode)
#+END_SRC

#+RESULTS:
: ((vertical-scroll-bars) (font . DM Mono 13))

* visual things
** matching parenthesis
#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
(setq-default show-paren-style 'parenthesis) ; highlight brackets only

(defadvice show-paren-function
    (after show-matching-paren-offscreen activate)
  "If the matching paren is offscreen, show the matching line in
the echo area. Has no effect if the character before point is not
of the syntax class ')'."
  (interactive)
  (let* ((cb (char-before (point)))
   (matching-text (and cb
           (char-equal (char-syntax cb) ?\) )
           (blink-matching-open))))
    (when matching-text (message matching-text))))
#+END_SRC

#+RESULTS:
: show-paren-function
** sticky function definition

this stickies the current function definition at the top of the buffer.

not used because it uses the header :(

#+BEGIN_SRC emacs-lisp
;; (use-package topsy
;;   ;; :quelpa (topsy :fetcher github :repo "alphapapa/topsy.el")
;;   :straight t
;;   :hook
;;   (prog-mode . topsy-mode)
;;   (magit-section-mode . topsy-mode))
#+END_SRC

* text manipulation

** wrap region in things

#+BEGIN_SRC emacs-lisp
(defun wrap-region-in-text (prefix suffix)
  (interactive)
  (save-excursion
    (goto-char (region-beginning))
    (insert prefix))
  (save-excursion
    (goto-char (region-end))
    (insert suffix)))
#+END_SRC

#+RESULTS:
: wrap-region-in-text

#+BEGIN_SRC emacs-lisp
(defun wrap-region-in-component (component)
  (wrap-region-in-text (s-concat "<" component ">") (s-concat "</" component ">")))
#+END_SRC

#+RESULTS:
: wrap-region-in-component

** wrap region in <Trans />

#+BEGIN_SRC emacs-lisp
(defun wrap-region-in-trans ()
  (interactive)
  (wrap-region-in-component "Trans"))
#+END_SRC

#+RESULTS:
: wrap-region-in-trans

* bug-hunter

  #+BEGIN_SRC emacs-lisp
(use-package bug-hunter
  :straight t)
  #+END_SRC

  #+RESULTS:

* selection candidates and search

** vertico

#+BEGIN_SRC emacs-lisp
(use-package vertico
  :straight (:files (:defaults "extensions/*"))
  :config
  (set-face-attribute 'vertico-current nil :background (doom-darken "#c792ea" 0.6))
  :init
  (vertico-mode))
#+END_SRC

#+RESULTS:
: t

*** prescient

prescient makes sorting and filtering more intelligent.

#+BEGIN_SRC emacs-lisp
(use-package vertico-prescient
  :straight t
  :init
  (vertico-prescient-mode 1)
  (prescient-persist-mode 1))
#+END_SRC

#+RESULTS:

** marginalia

#+BEGIN_SRC emacs-lisp
(use-package marginalia
  :straight (:host github :repo "minad/marginalia" :branch "main")
  :demand
  :config
  (setq marginalia-annotators
        '(marginalia-annotators-heavy
          marginalia-annotators-light))
  (marginalia-mode 0))
#+END_SRC

#+RESULTS:
: t

** consult

#+BEGIN_SRC emacs-lisp
(use-package consult
  :straight t
  :demand
  :config
  (setq consult-line-numbers-widen t)
  (setq completion-in-region-function #'consult-completion-in-region)
  (setq consult-async-min-input 3)
  (setq consult-async-input-debounce 0.5)
  (setq consult-async-input-throttle 0.8)
  (setq consult-narrow-key ">")

  ;; configure a function which returns the project root directory
  (autoload 'projectile-project-root "projectile")
  (setq consult-project-root-function #'projectile-project-root)

  ;; NOTE: check `embark-consult' for previews that can be used with the
  ;; default minibuffer and Embark collections.
  :bind (("C-x M-:" . consult-complex-command)
         ("C-x M-m" . consult-minor-mode-menu)
         ("C-x M-k" . consult-kmacro)
         ("M-g g" . consult-goto-line)
         ("M-g M-g" . consult-goto-line)
         ("M-X" . consult-mode-command)
         ("M-K" . consult-keep-lines)  ; M-S-k is similar to M-S-5 (M-%)
         ("M-s f" . consult-find)
         ("M-s g" . consult-ripgrep)
         ("M-s m" . consult-mark)
         ("C-j" . consult-buffer)
         ("C-x b" . consult-buffer)
         ("M-s i" . consult-imenu)
         ("M-s s" . consult-outline)    ; M-s o is `occur'
         ("M-y" . consult-yank-from-kill-ring)
         ("M-s l" . consult-line)
         :map consult-narrow-map
         ("?" . consult-narrow-help)))

;; enforce the switch-buffer binding
(bind-key* "C-j" 'consult-buffer)
#+END_SRC

#+RESULTS:
: consult-buffer

* minibuffer

#+BEGIN_SRC emacs-lisp
(use-package minibuffer
  :config
  (setq completion-styles '(prescient partial-completion))
  (setq completion-category-defaults nil)
  (setq completion-cycle-threshold 3)
  (setq completion-flex-nospace nil)
  (setq completion-pcm-complete-word-inserts-delimiters t)
  (setq completion-pcm-word-delimiters "-_./:| ")
  (setq completion-show-help nil)
  (setq completion-auto-help nil)
  (setq completion-ignore-case t)
  (setq-default case-fold-search t)   ; For general regexp

  ;; The following two are updated in Emacs 28.  They concern the
  ;; *Completions* buffer.  Note that I actually do not use that buffer,
  ;; because I rely on Embark's version of it.
  (setq completions-format 'one-column)
  (setq completions-detailed t)

  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)

  (setq enable-recursive-minibuffers t)
  (setq read-answer-short t)
  (setq resize-mini-windows t)
  (setq minibuffer-eldef-shorten-default t)

  (file-name-shadow-mode 1)
  (minibuffer-depth-indicate-mode 1)
  (minibuffer-electric-default-mode 1)

  ;; Defines, among others, aliases for common minibuffer commands to
  ;; Super-KEY.  Normally these should go in individual package
  ;; declarations, but their grouping here makes things easier to
  ;; understand.  Besides, they are related to the minibuffer.
  :bind (("s-f" . find-file)
         ("s-F" . find-file-other-window)
         ("s-d" . dired)
         ("s-D" . dired-other-window)
         :map minibuffer-local-completion-map
         ("C-j" . exit-minibuffer)
         ("<tab>" . minibuffer-force-complete)
         ;; De facto deprecated as I use Embark and its own completions'
         ;; buffer.
         :map completion-list-mode-map
         ("n" . next-line)
         ("p" . previous-line)
         ("f" . next-completion)
         ("b" . previous-completion)))
#+END_SRC

#+RESULTS:
: previous-completion

* ssh shortcuts

fns to reset directories to local:
#+BEGIN_SRC emacs-lisp
(defun local ()
  (interactive)
  (setq default-directory "/Users/jeroen"))

(defun reset-default-directory ()
  (interactive)
  (setq-local default-directory (file-name-directory (buffer-file-name))))

(defun open-shell-in-directory (directory &optional buffername)
  (interactive)
  (message "osid")
  (message directory)
  (message buffername)
  (with-temp-buffer
    (setq default-directory directory)
    (shell buffername)
    )
)
#+END_SRC

#+RESULTS:
: open-shell-in-directory

add remote endpoints

#+BEGIN_SRC emacs-lisp
(setq ssh-config '(
                   ("fxr" "/ssh:jeroen@fxr:")
                   ("tsf" "/ssh:july@factory:")
                   ("minifactory" "/ssh:paul@minifactory:")
                   ("factory-api" "/ssh:root@factory-api:")
                   ("lodder" "/ssh:paul@www.lodder.dev:")
                   ("mxomni" "/ssh:root@M-x-omni:")
                  ))

(dolist (elt ssh-config)
  (define-named-lambda
    (nth 0 elt)
    (lambda (directory)
      (interactive)
      (setq default-directory directory))
    '((nth 1 elt))
    )
  (define-named-lambda
    (s-concat "shell-" (nth 0 elt))
    (lambda (name directory)
      (interactive)
      (open-shell-in-directory directory (s-concat "*shell-" name "*")))
    elt
    )
)

(bind-key* "s-t" 'shell-tsf)
#+END_SRC

#+RESULTS:
: shell-tsf

* auto-fill-mode

#+BEGIN_SRC emacs-lisp
(auto-fill-mode 1)
#+END_SRC

#+RESULTS:
: yas--auto-fill

* which-key

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :straight t
  :init
  (which-key-mode 1))
#+END_SRC

#+RESULTS:
: t

* which-function-mode

#+begin_src emacs-lisp
(which-function-mode)
#+end_src

* ibuffer

[paul]
Let's try to get the ibuffer bound to =C-x C-b=, and have it open in the same
window, instead of a new window.

#+BEGIN_SRC emacs-lisp
(setq ibuffer-use-other-window nil)
(global-set-key (kbd "C-x C-b") `ibuffer)
#+END_SRC

#+RESULTS:
: ibuffer

[paul]
Unlike the regular buffer menu, =ibuffer= filters the buffers when you hit =RET=
when you are in the =Size Mode= column. Let's change this behaviour so that
="RET"= still visits the buffer, but pressing =f= causes it to filter still.

#+BEGIN_SRC emacs-lisp
(defvar ibuffer-mode-name-map
  (let ((map (make-sparse-keymap)))
    (define-key map [(mouse-2)] 'ibuffer-mouse-filter-by-mode)
    (define-key map (kbd "f") 'ibuffer-interactive-filter-by-mode)
    (define-key map (kbd "RET") 'ibuffer-visit-buffer)
    map))
#+END_SRC

#+RESULTS:
: ibuffer-mode-name-map

* swiper
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :config (global-set-key (kbd "C-s") 'swiper))
#+END_SRC


* tree-sitter

You might need to run: M-x =treesit-install-language-grammar=

#+BEGIN_SRC emacs-lisp
(setq treesit-language-source-alist
   '((bash "https://github.com/tree-sitter/tree-sitter-bash")
     (cmake "https://github.com/uyha/tree-sitter-cmake")
     (css "https://github.com/tree-sitter/tree-sitter-css")
     (elisp "https://github.com/Wilfred/tree-sitter-elisp")
     (go "https://github.com/tree-sitter/tree-sitter-go")
     (html "https://github.com/tree-sitter/tree-sitter-html")
     (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
     (json "https://github.com/tree-sitter/tree-sitter-json")
     (make "https://github.com/alemuller/tree-sitter-make")
     (markdown "https://github.com/ikatyang/tree-sitter-markdown")
     (python "https://github.com/tree-sitter/tree-sitter-python")
     (toml "https://github.com/tree-sitter/tree-sitter-toml")
     (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
     (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
     (yaml "https://github.com/ikatyang/tree-sitter-yaml")))

nil
#+END_SRC

#+RESULTS:

Activate the tree-sitter modes:

#+BEGIN_SRC emacs-lisp
(setq major-mode-remap-alist
 '((yaml-mode . yaml-ts-mode)
   (bash-mode . bash-ts-mode)
   ;; (js2-mode . js-ts-mode)
   ;; (typescript-mode . typescript-ts-mode)
   (json-mode . json-ts-mode)
   ;; (css-mode . css-ts-mode)
   ;; (python-mode . python-ts-mode)
   ))
#+END_SRC

#+RESULTS:
: ((yaml-mode . yaml-ts-mode) (bash-mode . bash-ts-mode) (js2-mode . js-ts-mode) (json-mode . json-ts-mode) (css-mode . css-ts-mode) (python-mode . python-mode))

** combobulate

#+BEGIN_SRC emacs-lisp
(use-package combobulate
  :straight (:host github :repo "mickeynp/combobulate" :branch "master")
  :preface
  ;; You can customize Combobulate's key prefix here.
  ;; Note that you may have to restart Emacs for this to take effect!
  (setq combobulate-key-prefix "C-c o")

  :config
  (setq combobulate-python-smart-indent nil)
  ;; Optional, but recommended.
  ;;
  ;; You can manually enable Combobulate with `M-x
  ;; combobulate-mode'.
  :hook ((python-ts-mode . combobulate-mode)
         (js-ts-mode . combobulate-mode)
         (css-ts-mode . combobulate-mode)
         (yaml-ts-mode . combobulate-mode)
         (json-ts-mode . combobulate-mode)
         (typescript-ts-mode . combobulate-mode)
         (tsx-ts-mode . combobulate-mode))
  ;; Amend this to the directory where you keep Combobulate's source
  ;; code.
  ;; :load-path ("path-to-git-checkout-of-combobulate"))
  )
#+END_SRC

#+RESULTS:
| combobulate-mode |

* ivy

#+BEGIN_SRC emacs-lisp
;; (use-package ivy
;;   :ensure t
;;   :config
;;   (ivy-mode 1)
;;   (setq ivy-use-virtual-buffers t
;;         ivy-count-format "%d/%d "
;;         ivy-wrasp t
;;         ivy-magic-tilde nil)
;;   (global-set-key (kbd "C-c C-r") 'ivy-resume))
#+END_SRC

* dired

#+BEGIN_SRC emacs-lisp
(defun regexp-orrify (&rest disjuncts)
  "Return the regexp disjunction of the given regexps"
  (cond ((null disjuncts) "")
        ((null (cdr disjuncts)) (car disjuncts))
        (t (concat (car disjuncts)
                   "\\|"
                   (apply #'regexp-orrify (cdr disjuncts))))))

(require 'dired-x)

(setq dired-dwim-target t)

(setq dired-omit-files
      (concat dired-omit-files
              "\\|"
              (regexp-orrify "\\.orgx$"
                             "^\.DS_Store$"
                             "^__MACOSX$"
                             "\\.pyc$"
                             "\\.pyo$"
                             "^__pycache__"
                             ".ipynb_checkpoints"
                             "\\.lprof$"
                             "\\.bak$"
                             "^ltximg$"
                             "^\\.~lock\\."
                             "^!.*pdf$"
                             "\\.~.*#")))

(add-hook 'dired-mode-hook
          #'(lambda ()
              (setq dired-guess-shell-alist-user
                    '(("\\.e?ps$" "gv" "lpr")
                      ("\\.pdf$" "mupdf" "xpdf" "lp" "acroread")
                      ("\\.mobi$" "ebook-viewer")
                      ("\\.epub$" "ebook-viewer")
                      ("\\.djvu$" "ebook-viewer")
                      ("\\.csv$" "loffice" "gnumeric")
                      ("\\.docx?$" "loffice")
                      ("\\.xlsx?$" "loffice" "gnumeric")
                      ("\\.pptx?$" "loffice")
                      ("\\.od[spt]$" "loffice")
                      ("\\.divx$" "mplayer")
                      ("\\.flv$" "mplayer")
                      ("\\.avi$" "mplayer")
                      ("\\.mpg$" "mplayer")
                      ("\\.mp4$" "mplayer")
                      ("\\.wmv$" "mplayer")
                      ("\\.mkv$" "mplayer")
                      ("\\.mov$" "mplayer")
                      ("\\.webm$" "mplayer")
                      ("Flash......$" "mplayer")
                      ("mplay......$" "mplayer")
                      ("\\.p[bgpn]m$" "geeqie" "display")
                      ("\\.gif$" "geeqie" "display")
                      ("\\.tif$" "geeqie" "display")
                      ("\\.png$" "geeqie" "display")
                      ("\\.jpe?g$" "geeqie" "display")
                      ("\\.svg$" "geeqie" "display")
                      ("\\.e?ps.g?z$" "gunzip -qc * | gv -"
                       (concat
                        "gunzip"
                        (if dired-guess-shell-gzip-quiet " -q")))
                      ("\\.e?ps.Z$" "zcat * | gv -"
                       (concat "znew"
                               (if dired-guess-shell-gzip-quiet " -q")
                               " " dired-guess-shell-znew-switches))
                      ("viewapp.asp" "xpdf"))
                    dired-listing-switches "-alh")
              (local-set-key "\C-c\C-zf" 'browse-url-of-dired-file)
              (dired-omit-mode)
              (whitespace-mode -1)))

  ;; Auto complete with ignore case
  (setq-default read-buffer-completion-ignore-case t)
  (setq-default read-file-name-completion-ignore-case t)

;; show filesize as kb, mb, etc:
(setq dired-listing-switches "-alh")
#+END_SRC

#+RESULTS:
: -alh

* expand-region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :straight t
  :bind ("C-=" . er/expand-region))
#+END_SRC

#+RESULTS:
: er/expand-region

* tramp

#+BEGIN_SRC emacs-lisp
  ;; ;; emacs 29.1 bug
  ;; (when (string-equal emacs-version "29.1")
  ;;        (with-current-buffer
  ;;            (url-retrieve-synchronously
  ;;             "https://git.savannah.gnu.org/cgit/emacs.git/plain/lisp/emacs-lisp/loaddefs-gen.el?h=emacs-29")
  ;;          (goto-char (point-min))
  ;;          (while (looking-at "^.+$") (forward-line))
  ;;          (eval-region (point) (point-max))))


  ;; (autoload #'tramp-register-crypt-file-name-handler "tramp-crypt")
  ;;   (use-package tramp
  ;;     :straight t
  ;;     :config
  ;;     (setq tramp-message-show-message "show-message")
  ;; (setq vc-ignore-dir-regexp
  ;;       (format "\\(%s\\)\\|\\(%s\\)"
  ;;               vc-ignore-dir-regexp
  ;;               tramp-file-name-regexp))
  ;; (setq tramp-verbose 1)
  ;; (setq tramp-default-method-alist
  ;;       '(("\\`localhost\\'" "\\`root\\'" "su")
  ;;         ("\\`localhost\\'" ".*" "ssh")
  ;;         ("\\`" ".*" "ssh")))
  ;;       (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
  ;;       (global-set-key (kbd "C-c t") 'tramp-cleanup-this-connection)
  ;;     )
#+END_SRC

#+RESULTS:
: t

make sure tramp works on windows:

#+BEGIN_SRC emacs-lisp
(when (eq window-system 'w32)
  (setq putty-directory "C:/Program Files/PuTTY")
  (setq tramp-default-method "plink")
  (when (and (not (string-match putty-directory (getenv "PATH")))
       (file-directory-p putty-directory))
    (setenv "PATH" (concat putty-directory ";" (getenv "PATH")))
    (add-to-list 'exec-path putty-directory)))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(setq epa-file-cache-passphrase-for-symmetric-encryption t)
#+END_SRC

#+RESULTS:
: t

** tramp-virtualenv

#+BEGIN_SRC emacs-lisp
(load-file "~/code/matthewlmcclure/tramp-virtualenv/tramp-virtualenv.el")
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC emacs-lisp
(use-package tramp-virtualenv
  :straight (:host github :repo "paulodder/tramp-virtualenv" :branch "master")
  :config
  (setq tramp-virtualenv-venvs-dir "~/.virtualenvs")
  )

(load-file "~/.emacs.d/straight/repos/tramp-virtualenv/tramp-virtualenv.el")

#+END_SRC

#+RESULTS:
: t

* etc

** ffap

#+BEGIN_SRC emacs-lisp
(defun my-find-file-at-point ()
  (interactive)
  (let ((file-path-and-line (thing-at-point 'filename t)))
    (if (and file-path-and-line (string-match-p "\\S-" file-path-and-line))
        (let* ((split-path-and-line (split-string file-path-and-line ":"))
               (file-path (car split-path-and-line))
               (line-number (when (cadr split-path-and-line)
                              (string-to-number (cadr split-path-and-line)))))
          ;; Check if current buffer is using tramp
          (when (tramp-tramp-file-p default-directory)
            ;; Extract tramp prefix from current buffer's default directory
            (let* ((tramp-prefix (tramp-dissect-file-name default-directory))
                   ;; Correctly format user and host
                   (tramp-user-host (concat (tramp-file-name-user tramp-prefix) "@" (tramp-file-name-host tramp-prefix))))
              ;; Prepend tramp prefix to file path
              (setq file-path (concat "/ssh:" tramp-user-host ":" file-path))))
          (if (file-exists-p file-path)
              (progn
                (find-file file-path)
                (when line-number
                  (goto-line line-number)))
            (message "File does not exist: %s" file-path)))
      (message "No valid file path found at point."))))

(global-set-key (kbd "C-M-o") 'my-find-file-at-point)
#+END_SRC

#+RESULTS:
: my-find-file-at-point

** comment-line

#+BEGIN_SRC emacs-lisp
(defun comment-dwim-or-line ()
  (interactive)
  "Comments if region selected, else comment line"
   (if (use-region-p)
   (save-excursion (call-interactively 'comment-dwim))
   (save-excursion (call-interactively 'comment-line)))

)

(defun crux-comment ()
  (interactive)
  "Comments if region selected, else comment line"
   (crux-with-region-or-line (save-excursion (call-interactively 'comment-dwim)))
)

(global-set-key (kbd "M-;") 'comment-dwim-or-line)
#+END_SRC

#+RESULTS:
: comment-dwim-or-line

** wrap-region

#+BEGIN_SRC emacs-lisp
(use-package wrap-region
  :straight t
  :diminish)
(wrap-region-global-mode)
(wrap-region-add-wrapper "`" "`")
(wrap-region-add-wrapper "'" "'")
(wrap-region-add-wrapper "|" "|")
;; (wrap-region-add-wrapper "=" "=")
(wrap-region-add-wrapper "$" "$")
(wrap-region-global-mode t)
#+END_SRC

** copy and comment

#+BEGIN_SRC emacs-lisp
(defun copy-and-comment ()
  (interactive)
  (if (use-region-p)
      (let ((beg (region-beginning))
            (end (region-end)))
        (call-interactively 'kill-ring-save)
        (call-interactively (lambda () (interactive) (comment-region beg end)))
      )))
(global-set-key (kbd "C-M-;") 'copy-and-comment)
#+END_SRC

#+RESULTS:
: copy-and-comment

** set default dir of

#+BEGIN_SRC emacs-lisp
(defun set-default-dir-of ()
  (interactive)
  (let ((b (read-buffer "Select buffer: " (buffer-list))))
    (setq default-directory (buffer-file-name (get-buffer (read-buffer "check" nil nil (lambda (b) (not (null (buffer-file-name (cdr b)))))))))
    ))
#+END_SRC

#+RESULTS:
: set-default-dir-of

** indent rigidly without aRrOw KEyS
#+BEGIN_SRC emacs-lisp
(setq indent-rigidly-map
      (let ((map (make-sparse-keymap)))
        (define-key map [left]  'indent-rigidly-left)
        (define-key map (kbd "C-M-b")  'indent-rigidly-left)
        (define-key map [right] 'indent-rigidly-right)
        (define-key map (kbd "C-M-f") 'indent-rigidly-right)
        (define-key map [S-right] 'indent-rigidly-right-to-tab-stop)
        map)
      )
#+END_SRC

** drag-stuff

#+BEGIN_SRC emacs-lisp
;; (load-org "drag-stuff.org")
(use-package drag-stuff
  :straight t)

(define-key indent-rigidly-map (kbd "C-p") 'drag-stuff-up)
(define-key indent-rigidly-map (kbd "C-n") 'drag-stuff-down)
(define-key indent-rigidly-map (kbd "C-f") 'drag-stuff-right)
(define-key indent-rigidly-map (kbd "C-b") 'drag-stuff-left)

(drag-stuff-mode)
#+END_SRC

** functions to add stuff to gitignores

#+BEGIN_SRC emacs-lisp
(defun macos-gitignore  ()
  (interactive)
  (let ((fullpath (string-join (list default-directory ".gitignore"))))
    (if (file-exists-p fullpath)
        (progn
          (shell-command-to-string "curl 'https://raw.githubusercontent.com/github/gitignore/main/Global/macOS.gitignore' >> .gitignore")
          (message (format "Added macos-gitignore in %s" default-directory))))))

(defun python-gitignore  ()
  (interactive)
  (let ((fullpath (string-join (list default-directory ".gitignore"))))
    (if (file-exists-p fullpath)
        (progn
          (shell-command-to-string "curl 'https://raw.githubusercontent.com/github/gitignore/main/Python.gitignore' >> .gitignore")
          (message (format "Added python-gitignore in %s" default-directory))))))

(defun emacs-gitignore  ()
  (interactive)
  (let ((fullpath (string-join (list default-directory ".gitignore"))))
    (if (file-exists-p fullpath)
        (progn
          (shell-command-to-string "curl 'https://raw.githubusercontent.com/github/gitignore/main/Global/Emacs.gitignore' >> .gitignore")
          (message (format "Added emacs-gitignore in %s" default-directory))))))
#+END_SRC

#+RESULTS:
: emacs-gitignore

** occur with current selection

#+BEGIN_SRC emacs-lisp
(defun occur-selection ()
  (interactive)
  (when (region-active-p)
    (let (deactivate-mark)
      (occur (regexp-quote (buffer-substring (region-beginning) (region-end)))))))
(global-set-key [(super o)] 'occur-selection)

#+END_SRC

#+RESULTS:
: occur-selection

** many configurations

miscellaneous configurations

#+BEGIN_SRC emacs-lisp
;; (savehist-mode 1)

;; ;; Lazy prompting. Change "yes or no" to "y or n"
;; ;; http://dl.dropboxusercontent.com/u/3968124/sacha-emacs.html
(fset 'yes-or-no-p 'y-or-n-p)

(setq-default
fill-column 79
standard-indent 2

 ;;  ;; comment for now
;;  ;; tab-always-indent 'complete
;;  ;; indent-tabs-mode nil

;;  sentence-end-double-space nil
;;  indicate-empty-lines t

;;  european-calendar-style t
;;  calendar-date-style 'european
;;  calendar-week-start-day 1
;;  diary-file "~/.diary"

;;  display-time-24hr-format t
;;  display-time-day-and-date t
;;  display-time-string-forms
;;  '((if (and (not display-time-format) display-time-day-and-date)
;;  (format-time-string "%a %b %e " now) "")
;;    (format-time-string (or display-time-format
;;          (if display-time-24hr-format "%H:%M" "%-I:%M%p"))
;;      now))
;;  calendar-time-display-form
;;  '(24-hours ":" minutes
;;       (if time-zone " (") time-zone (if time-zone ")"))


;;  delete-old-versions t
;;  vc-make-backup-files t
;;  backup-directory-alist '((".*" . "~/.emacs.d/emacs-backups"))

;;  mail-user-agent 'gnus-user-agent
;;  ps-paper-type 'a4

;;  ediff-split-window-function 'split-window-horizontally
;;  ediff-window-setup-function 'ediff-setup-windows-plain

 enable-recursive-minibuffers t
;;  debug-on-error nil

;;  compile-command "remake install"

;;  aurel-download-directory "~/code/src/aur"

;;  async-shell-command-buffer 'new-buffer ; Don't ask.
;;  display-buffer-alist '(("*Async Shell Command*" . (display-buffer-no-window)))
;;  ibuffer-use-other-window nil
;;  Man-width 80
;;  Man-notify-method 'aggressive

;;  eshell-prompt-function #'(lambda () "$ ")
 )

;; ;; (add-to-list 'ibuffer-never-show-predicates "^\*Async")

;; (dolist (mode '(scroll-bar-mode))
;;   (if (fboundp mode) (funcall mode -1)))

;; ;; Edit from  chrome
;; ;; (edit-server-start)

;; ;; Save point position between sessions
;; ;; (use-package saveplace
;; ;;   :ensure t
;; ;;   :config
;; ;;   (setq-default save-place t)
;; ;;   (setq save-place-file (expand-file-name ".places" user-emacs-directory)))
#+END_SRC

#+RESULTS:
: t

** delete line but don't kill

#+BEGIN_SRC emacs-lisp
(defun my-smart-delete-line ()
  "Delete to the end of the line or the whole line without adding to kill ring.
If at the end of the line, delete the entire line including the newline,
then move to the start of the next line's non-whitespace text. Otherwise,
delete to the end of the line."
  (interactive)
  (if (eolp) ; Check if cursor is at the end of line
      (progn
        (delete-region (line-beginning-position) (min (1+ (line-end-position)) (point-max))) ; delete whole line including newline
        (back-to-indentation)) ; move to start of non-whitespace text on next line
    (delete-region (point) (line-end-position)))) ; else delete to end of line

(global-set-key (kbd "C-k") 'my-smart-delete-line)
#+END_SRC

#+RESULTS:
: my-smart-delete-line

* unicode-fonts

https://stackoverflow.com/questions/16270105/why-are-some-unicode-characters-invisible-in-emacs
#+BEGIN_SRC emacs-lisp
(use-package unicode-fonts
  :straight t)
  (require 'unicode-fonts)
  (unicode-fonts-setup)
#+END_SRC

* magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :straight t
  :bind (
         ("C-x g" . magit-status)
         :map magit-mode-map
         ("C-j" . consult-buffer))
  :diminish magit-minor-mode)
#+END_SRC

#+RESULTS:

** magit-section

this is a standalone package which we want/need (also for org-roam)

#+BEGIN_SRC emacs-lisp
(use-package magit-section
  :straight t)
#+END_SRC

** magit-todos

shows "TODO" comments of a codebase in magit.

#+BEGIN_SRC emacs-lisp
(use-package magit-todos
  :straight t
  :after magit
  :config (magit-todos-mode 1))
#+END_SRC

#+RESULTS:
: t

* yasnippet

#+BEGIN_SRC emacs-lisp
;; (add-hook 'yas-minor-mode-hook (lambda () (yas-activate-extra-mode
;;           'fundamental-mode)))
;; (use-package yasnippet
;;   :config
;;   (yas-global-mode 1))

;; (add-hook 'yas-minor-mode-hook
;;           (lambda ()
;;             (yas-activate-extra-mode 'fundamental-mode)))
(use-package yasnippet
  :straight t)
(yas-global-mode 1)
#+END_SRC

#+RESULTS:
: t

* multiple-cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :straight t)

(bind-keys* ((kbd "C-.") . mc/mark-next-like-this)
            ((kbd "C-,") . mc/mark-previous-like-this)
            ((kbd "C-M-.") . mc/unmark-next-like-this)
            ((kbd "C-M-,") . mc/unmark-previous-like-this)
             ((kbd "C-c C-,") . mc/mark-all-like-this))
#+END_SRC

#+RESULTS:
: mc/mark-all-like-this

* projectile

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :diminish
  :straight t)
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
(projectile-mode +1)

(defun projectile-replace-multiple (old2new)
  (let* ((directory (projectile-acquire-root))
         (old-text (read-string
                    (projectile-prepend-project-name "Replace: ")
                    (projectile-symbol-or-selection-at-point)))
         (new-text (read-string
                    (projectile-prepend-project-name
                     (format "Replace %s with: " old-text))))
         (files (projectile-files-with-string old-text directory)))
    (cl-mapcar (lambda () (
                           (progn (fileloop-initialize-replace old-text new-text files 'default)
                                  (fileloop-continue))
                           ) old2new))
  ))
#+END_SRC

#+RESULTS:
: t

* format-all

#+BEGIN_SRC emacs-lisp
(use-package inheritenv
  :straight (
             :host github :repo "purcell/inheritenv"
             :branch "main" :files ("inheritenv.el")
             )
  )

(use-package format-all
  :straight t
  :config
  (add-hook 'ruby-mode-hook 'format-all-mode)
  (add-hook 'yaml-mode-hook 'format-all-mode)
  (add-hook 'emacs-lisp-mode 'format-all-mode)
  )
#+END_SRC

#+RESULTS:
: t

* web-mode

web-mode ensures syntax highlighting for a bunch of web code files (html), including .html.erb

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode
  ;; ("\\.ejs\\'" "\\.hbs\\'" "\\.html\\'" "\\.php\\'" "\\.[jt]sx?\\'" "\\.svelte\\'")
  ("\\.ejs\\'" "\\.hbs\\'" "\\.html\\'" "\\.php\\'" "\\.svelte\\'")
  :config
  (setq web-mode-content-types-alist '(
                                       ;; ("jsx" . "\\.[jt]sx?\\'")
                                       ("html" . "\\.svelte\\'")
                                       ))
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-script-padding 2)
  (setq web-mode-block-padding 2)
  (setq web-mode-style-padding 2)
  (setq web-mode-enable-auto-pairing t)
  (setq web-mode-enable-auto-closing t)
  (setq web-mode-enable-current-element-highlight t))

(add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.svelte\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.css\\'" . web-mode))

nil
#+END_SRC

#+RESULTS:

** .astro files

#+BEGIN_SRC emacs-lisp
(define-derived-mode astro-mode web-mode "astro")
(setq auto-mode-alist
      (append '((".*\\.astro\\'" . astro-mode))
              auto-mode-alist))

nil
#+END_SRC

#+RESULTS:

* lsp / eglot

#+BEGIN_SRC emacs-lisp
(define-derived-mode jpj-js-mode web-mode "jpj-js"
  "A major mode derived from web-mode, for editing .(j|t)s(x) files with eglot support.")
(add-to-list 'auto-mode-alist '("\\.\\([jt]sx?\\|mjs\\)\\'" . jpj-js-mode))

;; (defun maybe-set-pylsp-path-on-ssh ()
;;     (if (s-starts-with? "/ssh:jeroen@fxr" (buffer-file-name))
;;         (setq-local eglot-server-programs
;;                     '(
;;                       (python-mode . ("/home/jeroen/.virtualenvs/base/bin/pylsp"))
;;                       ))
;;       (setq-local eglot-autoreconnect nil)
;; ))

(defun eglot-ensure-if-not-ssh ()
    (if (not (s-starts-with? "/ssh:jeroen@fxr" (buffer-file-name)))
        (eglot-ensure)))

(defun set-eglot-server-program-in-typescript-buffer ()
  (when (string-equal "tsx" (file-name-extension buffer-file-name))
    (setq-local eglot-server-programs '(
                                        (web-mode . ("typescript-language-server" "--stdio"))
                                        ))
    (eglot-ensure)
    ))

(use-package eglot
  :hook ((python-mode . eglot-ensure-if-not-ssh)
         (jpj-js-mode . eglot-ensure)
         (typescript-ts-mode . eglot-ensure))
  :config
  (add-to-list 'eglot-server-programs
               '(python-mode . ("~/.virtualenvs/base/bin/pylsp")))
  (add-to-list 'eglot-server-programs
               '(typescript-ts-mode . ("typescript-language-server" "--stdio")))
  (add-to-list 'eglot-server-programs
               '(jpj-js-mode . ("typescript-language-server" "--stdio")))
  (add-to-list 'eglot-server-programs
               '(astro-mode . ("astro-ls" "--stdio"
                               :initializationOptions
                               (:typescript (:tsdk "./node_modules/typescript/lib")))))
  (bind-keys* :map eglot-mode-map
                ("C-c e r" . eglot-rename)
                ("C-c e a" . eglot-code-actions)
                ("C-c e i" . eglot-code-action-inline)
                ("C-c e q" . eglot-code-action-quickfix)
                ("C-c e x" . eglot-code-action-extract)
                ("C-c e o" . eglot-code-action-organize-imports)
                )
  :init
  (add-hook 'astro-mode-hook 'eglot-ensure)
  )
#+END_SRC

#+RESULTS:
| eglot-ensure | combobulate-mode |

** lsp-mode

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
 :straight t)
#+END_SRC

#+RESULTS:

*** biome (js formatter)

#+BEGIN_SRC emacs-lisp
(use-package lsp-biome
    :straight (:host github :repo "cxa/lsp-biome" :branch "main"))
#+END_SRC

#+RESULTS:

* restclient

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :straight t)
#+END_SRC

#+RESULTS:

* poly-mode

#+BEGIN_SRC emacs-lisp
(use-package polymode
  :straight t)

(use-package poly-markdown
  :straight t)
#+END_SRC

#+RESULTS:

* ruby

if ruby interpreter complains about unknown file encodings, try this:

#+BEGIN_SRC emacs-lisp
;; (setq ruby-insert-encoding-magic-comment nil)
#+END_SRC

** rails
*** projectile-rails

projectile-rails is used for navigation inside a rails project.

#+BEGIN_SRC emacs-lisp
(use-package projectile-rails
  :ensure t)
(projectile-rails-global-mode)
(define-key projectile-rails-mode-map (kbd "C-c e") 'projectile-rails-command-map)
#+END_SRC

#+RESULTS:
: projectile-rails-command-map

* html

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :straight t
  :config (setq emmet-expand-jsx-className? t))

(defun web-mode-init-emmet-hook ()
  (emmet-mode))

(add-hook 'web-mode-hook  'web-mode-init-emmet-hook)
#+END_SRC

#+RESULTS:
| web-mode-init-emmet-hook | prettier-js-mode | web-mode-init-prettier-hook | web-mode-init-hook |

* react

i use a number of packages here: first, web-mode, which does a bunch of stuff. initialization:

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.jsx?$" . web-mode)) ;; auto-enable for .js/.jsx files
(setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'")))

(defun web-mode-init-hook ()
  "Hooks for Web mode.  Adjust indent."
  (setq web-mode-markup-indent-offset 2))

(add-hook 'web-mode-hook  'web-mode-init-hook)
#+END_SRC

#+RESULTS:
| web-mode-init-prettier-hook | web-mode-init-hook | my/activate-tide-mode | prettier-js-mode |

second package: prettier-js, which autoformats js files on save. for this, i also install
add-node-modules-path

#+BEGIN_SRC emacs-lisp
(use-package add-node-modules-path
  :straight t)

(use-package prettier-js
  :straight t
  :config
  (add-hook 'js-mode-hook 'prettier-js-mode)
  (add-hook 'web-mode-hook 'prettier-js-mode)
  (eval-after-load 'js-mode (lambda ()
                              (define-key js-mode-map (kbd "C-c C-c")  'indium-reload)))
  (setq prettier-js-args (list "--no-semi" "--single-quote"))
  )

(defun web-mode-init-prettier-hook ()
  (when (string-equal "css" (file-name-extension buffer-file-name))
              (prettier-js-mode)
              (add-hook 'before-save-hook 'prettier-js nil 'local)))

(eval-after-load 'web-mode
    '(progn
       (add-hook 'web-mode-hook #'add-node-modules-path)
       (add-hook 'web-mode-hook #'web-mode-init-prettier-hook)
       ))
#+END_SRC

#+RESULTS:
| web-mode-init-prettier-hook | add-node-modules-path | copilot-mode | prettier-js-mode | web-mode-init-hook | web-mode-init-emmet-hook |

then, flymake-eslint, which does eslint:

#+BEGIN_SRC emacs-lisp
;; (defcustom flymake-eslint-executable-name "eslint"
;;   "Name of executable to run when checker is called.  Must be present in variable `exec-path'."
;;   :type 'string
;;   :group 'flymake-eslint)

;; (add-hook 'web-mode-hook
;;   (lambda ()
;;     (flymake-eslint-enable)))
#+END_SRC

#+RESULTS:

** shadcn/ui install shortcut

#+BEGIN_SRC emacs-lisp
(defun find-root-dir-with (filename &optional dir)
  "Find the root directory containing FILENAME, starting from DIR or `default-directory'."
  (let ((dir (or dir default-directory)))
    (if (file-exists-p (expand-file-name filename dir))
        dir
      (unless (or (null dir) (string= "/" dir))
        (find-root-dir-with filename (file-name-directory (directory-file-name dir)))))))

(defun jpj/add-shadcn-ui-component (component)
  "Prompt for a shadcn-ui component and add it using bunx in the directory containing package.json."
  (interactive "sEnter the component name to add: ")
  (let* ((root-dir (find-root-dir-with "package.json"))
         (command (format "pnpm dlx shadcn@latest add %s" component)))
    (if root-dir
        (let ((default-directory root-dir))
          ;; Execute command in a shell and display output
          (compile command))
      (message "package.json not found in any parent directory"))))
#+END_SRC

#+RESULTS:
: jpj/add-shadcn-ui-component

* json

=flymake-json= can validate JSON.

#+BEGIN_SRC emacs-lisp
(use-package flymake-json
  :straight t
  :config
  (global-set-key (kbd "C-c j v") 'flymake-json-load)
  )
#+END_SRC

#+RESULTS:
: t

* deft / note-taking

#+BEGIN_SRC emacs-lisp
(use-package deft
         :straight t
         :commands (deft)
         :config (setq deft-directory "~/Documents/notes"
                       deft-extensions '("org" "md" "txt")
                       deft-default-extension "org"
                       deft-auto-save-interval 300
                       deft-use-filter-string-for-filename t))



(bind-key* (kbd "C-c C-;") 'deft)
#+END_SRC

#+RESULTS:
: deft

* ASP / KRR

#+BEGIN_SRC emacs-lisp
(use-package pasp-mode
  :straight t)

(defun eval-region-pasp ()
  (interactive)
  (let ((code (if (region-active-p)
                  (buffer-substring-no-properties (region-beginning)
                                                  (region-end))
                (org-element-property :value (org-element-at-point))))
        (this-buf (current-buffer)))
    (save-window-excursion (switch-to-buffer-other-window (concat "*"
                                                                  (file-name-base)
                                                                  "*"))
                           (end-of-buffer)
                           (insert (format "print_answer_sets(\"\"\"%s\"\"\")"
                                           code))
                           (comint-send-input)
                           (switch-to-buffer this-buf))))

;; (with-temp-buffer )
(defun save-and-run-pasp ()
  (interactive)
  (progn
    (save-buffer)
    (pasp-run-buffer)))
(define-key pasp-mode-map (kbd "C-c C-c") #'save-and-run-pasp)

;; patch this function to add quotes around filepath
(defun pasp-generate-command (encoding &optional instance)
  "Generate Clingo call with some ASP input file.

   Argument ENCODING The current buffer which holds the problem encoding.
   Optional argument INSTANCE The problem instance which is solved by the encoding.
     If no instance it is assumed to be also in the encoding file."
     (if 'instance
         (concat pasp-clingo-path " " pasp-clingo-options " '" encoding "' " instance)
       (concat pasp-clingo-path " " pasp-clingo-options " '" encoding "'")))

(setq pasp-clingo-options "-n 0")
#+END_SRC

#+RESULTS:
: -n 0

#+BEGIN_SRC emacs-lisp
(defun pasp-gvis ()
  (interactive)
  (let ((answerset (buffer-substring (region-beginning)
                                                  (region-end))))
    (shell-command (format "python /Users/jeroen/code/UvA/msc/krr/gvis.py '%s'"
                                           answerset))))

(eval-after-load 'pasp-compilation-mode
                 '(define-key pasp-compilation-mode-map (kbd "C-c C-v") 'pasp-gvis))
#+END_SRC

#+RESULTS:

* R / r-mode / ess / rrrrrr

ESS manual:

https://ess.r-project.org/Manual/ess.html

#+BEGIN_SRC emacs-lisp
;; (use-package ess
;;   :straight t
;;   :config
;;   (add-hook `inferior-ess-mode-hook (lambda () (setq comint-input-ring-size 1500)))
;;   (setq ess-eval-visibly 'nowait) ;; don't hang buffer when exec-ing code
;;   (setq ess-fancy-comments nil) ;; don't indent comments
;;   )

(eval-after-load "comint"
   '(progn
      (define-key comint-mode-map [up]
        'comint-previous-matching-input-from-input)
      (define-key comint-mode-map [down]
        'comint-next-matching-input-from-input)

      ;; also recommended for ESS use --
      (setq comint-move-point-for-output 'others)
      ;; somewhat extreme, almost disabling writing in *R*, *shell* buffers above prompt:
      ;; (setq comint-scroll-to-bottom-on-input 'this)
      ))
#+END_SRC

#+RESULTS:
: others

i want some custom keybindings in order to speed up writing R code:

#+BEGIN_SRC emacs-lisp
(defun load-ess-mode-maps ()
  (dolist (m (list ess-r-mode-map inferior-ess-mode-map))
    (bind-keys :map m
               ("M-i" . ess-insert-assign)
               )))
(add-hook `inferior-ess-mode-hook 'load-ess-mode-maps)
#+END_SRC

#+RESULTS:
| load-ess-mode-maps | (lambda nil (setq comint-input-ring-size 1500)) |

notes about ESS:
- try code nav using M-{, M-} and M-h.
- can customize window display setup (see ESS manual)
- execute old code under point with =RET= (or just copy over with =C-c RET=)
- keep a record of R session with =C-x C-w= (write file; this file has special
  mode)
- =C-c C-o= to remove previous output block (=C-c C-x= to execute without
  output in the first place)
- =M-h C-w= to remove previous command + output
- =ess-transcript-clean-region|buffer= to strip output from a transcript! (=C-c C-w=)
- =C-c M-r= finish partially typed line with first match found (startswith)
- hotkeys (with =C-u= prefix to output in buffer itself):
  + =C-c C-s= sends search()
  + =C-c C-x= sends objects()
  + =C-c M-l= loads a file with =source()=
  + =C-c C-v= display help for object
  + =C-c C-q= ess-quit. use this to clean up session!
  + =C-c C-z= switch between process and script buffer
- =edit|fix(function)= opens buffer to edit that fn! (fix = update fn when kill
  buffer)

** view data in ess

#+BEGIN_SRC emacs-lisp
;; (use-package ess-R-data-view
;;   :straight t
;;   :config
;;   (bind-key* "C-x w" 'ess-R-dv-ctable)
;;    )



;; (use-package ess-view
;;   :straight t)

;; (setq ess-view--spreadsheet-program "/Applications/Numbers.app")
#+END_SRC

#+RESULTS:
: t


** poly-mode R

for R:

#+BEGIN_SRC emacs-lisp
;; (use-package poly-R
;;   :straight t)
#+END_SRC

#+RESULTS:

* keybase

run: =git clone https://github.com/paulodder/keybase-chat=

#+BEGIN_SRC emacs-lisp
(setq my-keybase-username "jpj8")
(use-package keybase-chat
  :straight (keybase-chat
             :host github
             :repo "paulodder/keybase-chat"
             )
)

(bind-key (kbd "C-c k") 'keybase-join-channel)
#+END_SRC

#+RESULTS:
: keybase-join-channel

* avy
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-;") 'avy-goto-char-2)
(global-set-key (kbd "M-g M-g") 'avy-goto-line)
#+END_SRC

#+RESULTS:
: avy-goto-line
* org-mode

** alphabetic lists are a-okay!

#+BEGIN_SRC emacs-lisp
(setq org-list-allow-alphabetical t)
#+END_SRC

** more italic lines

#+BEGIN_SRC emacs-lisp
(setf (nth 4 org-emphasis-regexp-components) 10)
#+END_SRC

#+RESULTS:
: 10

** inline images

#+BEGIN_SRC emacs-lisp
(setq org-image-actual-width '(700))
#+END_SRC

#+RESULTS:
| 1100 |

** change size of latex equations

Change the size of inline latex eqs (=C-x C-c C-l=).

#+BEGIN_SRC emacs-lisp
(plist-put org-format-latex-options :scale 1.8)
#+END_SRC

#+RESULTS:
| :foreground | default | :background | default | :scale | 1.8 | :html-foreground | Black | :html-background | Transparent | :html-scale | 1.0 | :matchers | (begin $1 $ $$ \( \[) |

In order to create those images when opening org file, insert this:
=#+STARTUP: latexpreview=.

** speed commands

when point is at the beginning of headers, use keys to quickly navigate etc:

#+BEGIN_SRC emacs-lisp
(setq org-use-speed-commands t)

;; adding to these commands is possible:
;; (add-to-list 'org-speed-commands (cons "S" 'widen))
#+END_SRC

the key =?= lists an overview of the commands

** org-table: realign and move up/down

like TAB but then moving up/down rows.

#+BEGIN_SRC emacs-lisp
(defun org-table-realign-and-move-down ()
  "Realign the table and move down one row in the same column."
  (interactive)
  (let ((current-column (org-table-current-column)))
    (org-table-align)
    (org-table-next-row)
    (org-table-goto-column current-column)))

(defun org-table-realign-and-move-up ()
  "Realign the table and move up one row in the same column."
  (interactive)
  (let ((current-column (org-table-current-column)))
    (org-table-align)
    ;; Move up a line and then jump to the correct column.
    (previous-line)
    (org-table-goto-column current-column)))
#+END_SRC

#+RESULTS:
: org-table-realign-and-move-up

** keybindings

#+BEGIN_SRC emacs-lisp
(defun exec-source-block ()
  "Copies and pastes the current source block to
  the active python session and executes it."
  (interactive)
  (let* ((this-window (selected-window))
         (sb-content (if (region-active-p)
                         (substring-no-properties (buffer-string)
                                                  (- (region-beginning)
                                                     1)
                                                  (- (region-end)
                                                     1))
                       (string-trim (org-element-property :value (org-element-at-point)))))
         (sb-info (org-babel-get-src-block-info))
         (maybe-cpaste-content (if (string= "python"
                                            (first sb-info))
                                   (concat "\n%cpaste\n" sb-content "\n--")
                                 sb-content)))
    (save-excursion
      (org-babel-switch-to-session)
      (end-of-buffer)
      (insert maybe-cpaste-content)
      (comint-send-input)
      (select-window this-window))))


(defun org-src-exec-blocks-up-until ()
  "applies exec-source-block to all source blocks up until current point"
  (interactive)
  (let ((max-point (point)))
    (save-excursion
      (beginning-of-buffer)
      (org-babel-next-src-block)
      (while (<= (point) max-point)
        (progn
          (org-babel-next-src-block)
          (exec-source-block))))))

(define-key org-mode-map (kbd "C-c C-c") 'exec-source-block)
(define-key org-mode-map (kbd "C-c c") 'org-ctrl-c-ctrl-c)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my-org-contextual-move-down ()
  (interactive)
  (if (org-at-table-p)
      (org-table-realign-and-move-down)
    (org-babel-next-src-block)))

(defun my-org-contextual-move-up ()
  (interactive)
  (if (org-at-table-p)
      (org-table-realign-and-move-up)
    (org-babel-previous-src-block)))


(bind-keys* :map org-mode-map
            ((kbd "M-n") . my-org-contextual-move-down)
            ((kbd "M-p") . my-org-contextual-move-up)
            )
#+END_SRC

#+RESULTS:
: my-org-contextual-move-up

** toggle code block execution

#+BEGIN_SRC emacs-lisp
(defun org-toggle-execution-on-export ()
  (interactive)
  (setq org-export-babel-evaluate (not org-export-babel-evaluate))
  (message "org-export-babel-evaluate turned %s" (if org-export-babel-evaluate "on" "off")))
#+END_SRC

#+RESULTS:
: org-toggle-execution-on-export

** [paul] execute source block

Let's write a function that executes a command in the corresponding shell
without having the whole file freeze. Instead, we copy the current code block's
buffer content and paste it in the shell, and then execute the command.


#+BEGIN_SRC emacs-lisp
(defun org-execute-code-in-shell  (&optional arg _info)
  "Copy current src block's contents and execute it in code shell buffer."
  (interactive)
  (save-window-excursion
    (org-babel-switch-to-session arg (org-babel-get-src-block-info))
    (end-of-buffer)
    (yank)
    (comint-send-input)
    (comint-send-input)
    (comint-send-input)
    ))

(defun org-execute-code-in-shell  (&optional arg _info)
  "Copy current src block's contents and execute it in code shell buffer."
  (interactive "P")
  (let ((this-window (selected-window))
        (info (org-babel-get-src-block-info)))
    (org-babel-switch-to-session arg info)
    (end-of-buffer)
    (yank)
    (comint-send-input)
    (comint-send-input)
    (comint-send-input)
    (select-window this-window)
    ))
#+END_SRC

#+RESULTS:
: org-execute-code-in-shell

Let's make =C-c C-c= execute the =execute-code-in-shell= function, and let =C-c
c= execute the regular =org-ctrl-c-ctrl-c= function.
#+BEGIN_SRC emacs-lisp
(org-defkey org-mode-map "\C-c\C-c" `org-execute-code-in-shell)
(org-defkey org-mode-map "\C-c\c" 'org-ctrl-c-ctrl-c)
#+END_SRC

#+RESULTS:
: org-ctrl-c-ctrl-c

** copy src block

#+BEGIN_SRC emacs-lisp
(fset 'org-yank-src-block-into-session
   (kmacro-lambda-form [?\C-c ?\' ?\C-x ?h ?\M-w ?\C-u ?\C-  ?\C-u ?\C-  ?\C-c ?\' ?\C-c ?\C-v ?\C-z ?\C-a ?\C-  ?\C-e backspace ?\C-e ?  ?\C-\M-y ?\M-o] 0 "%d"))

(define-key org-mode-map (kbd "C-c y") 'org-yank-src-block-into-session)
#+END_SRC

#+RESULTS:
: org-copy-src-block

** copy and execute python source block

#+BEGIN_SRC emacs-lisp
(defun copy-source-block ()
  "Copies the current source block."
  (interactive)
  (let* ((this-window (selected-window))
         (sb-content (if (region-active-p)
                         (substring-no-properties (buffer-string)
                                                  (- (region-beginning)
                                                     1)
                                                  (- (region-end)
                                                     1))
                       (string-trim (org-element-property :value (org-element-at-point)))))
         (sb-info (org-babel-get-src-block-info)))
    (kill-new sb-content)))

(defun exec-source-block ()
  "Copies and pastes the current source block to
  the active python session and executes it."
  (interactive)
  (let* ((this-window (selected-window))
         (sb-content (if (region-active-p)
                         (substring-no-properties (buffer-string)
                                                  (- (region-beginning)
                                                     1)
                                                  (- (region-end)
                                                     1))
                       (string-trim (org-element-property :value (org-element-at-point)))))
         (sb-info (org-babel-get-src-block-info))
         (maybe-cpaste-content (if (string= "python"
                                            (first sb-info))
                                   (concat "\n%cpaste\n" sb-content "\n--")
                                 sb-content)))
    (save-excursion
      (org-babel-switch-to-session)
      (end-of-buffer)
      (insert maybe-cpaste-content)
      (comint-send-input)
      (select-window this-window))))

(org-defkey org-mode-map "\C-c\C-c" `exec-source-block)
(org-defkey org-mode-map "\C-\M-w" `copy-source-block)
#+END_SRC

#+RESULTS:
: copy-source-block

** set correct python interpreter

#+BEGIN_SRC emacs-lisp
(setq org-babel-python-command "ipython -i --simple-prompt")
#+END_SRC

#+RESULTS:
: ipython -i --simple-prompt

** enable org-mode auto-fill-mode and org-indent-mode automatically

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'auto-fill-mode)
(add-hook 'org-mode-hook 'org-indent-mode)
nil
#+END_SRC

** auto-insert for org-mode

#+BEGIN_SRC emacs-lisp
(defun insdate-insert-current-date (&optional omit-day-of-week-p)
  "Insert today's date using the current locale.
  With a prefix argument, the date is inserted without the day of
  the week."
  (interactive "P*")
  (calendar-date-string (calendar-current-date) nil
                        omit-day-of-week-p))

(defun my/org-template ()
  (let ((session-name (file-name-sans-extension (file-name-nondirectory buffer-file-name))))
    (message session-name)
    (insert
     (format  "#+TITLE: %s
,#+AUTHOR: July
,#+DATE: %s
,#+LATEX_HEADER: \\usepackage{mathpazo}
,#+PROPERTY: header-args :exports both :session %s :cache :results value
,#+OPTIONS: ^:nil
" session-name (insdate-insert-current-date t) session-name)
     ;; (org-mode-restart)
     )))
(define-auto-insert "\\.org$" #'my/org-template)
  ;; ))
#+END_SRC

#+RESULTS:
: [my/org-template my/org-template]

** org-roam

#+BEGIN_SRC emacs-lisp
  (setq org-roam-directory (file-truename "~/Documents/org-roam"))

  (use-package emacsql-sqlite-builtin
    :straight t)
  ;; (use-package emacsql-sqlite-builtin)

  (use-package org-roam
    :straight t
    :after (org emacsql-sqlite-builtin)
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n i" . org-roam-node-insert)
           ("C-c n t" . org-roam-tag-add)
           ("C-c n a" . org-roam-alias-add))
    :config
    ;; (setq org-roam-v2-ack t)
    (setq org-roam-database-connector 'sqlite-builtin)
    (setq org-roam-completion-everywhere t)
    (setq org-roam-capture-templates
          '(
            ("d" "default" plain
             "%?" ;; the template content; %? is where the cursor will land
             :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}\n")
             :unnarrowed t)
            ("b" "book notes" plain
             (file "~/Documents/org-roam/templates/book-notes-template.org")
             :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: book")
             :unnarrowed t)
            ("r" "paper" plain
             (file "~/Documents/org-roam/templates/paper-notes-template.org")
             :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: paper")
             :unnarrowed t)
            ("p" "project " plain
             (file "~/Documents/org-roam/templates/project-template.org")
             :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}\n#+FILETAGS: project")
             :unnarrowed t)
            ))
    (org-roam-db-autosync-mode)
    )

  (setq org-roam-directory (file-truename "~/Documents/org-roam"))
#+END_SRC

#+RESULTS:
: /Users/jeroen/Documents/org-roam

using deft for org-roam note searching:

#+BEGIN_SRC emacs-lisp
;; (use-package deft
;;     :config
;;     (setq deft-directory org-directory
;;           deft-recursive t
;;           deft-strip-summary-regexp ":PROPERTIES:\n\\(.+\n\\)+:END:\n"
;;           deft-use-filename-as-title t)
;;     :bind
;;     ("C-c n d" . deft))
#+END_SRC

** edit random comments and strings with org-mode

If you wanna edit some large comment (e.g. docstring) using org-mode editing
ease, use this:

#+BEGIN_SRC emacs-lisp
(use-package poporg
      :bind (("C-c /" . poporg-dwim)))
#+END_SRC

#+RESULTS:
: poporg-dwim


** org exporting
*** html: export images embedded in html file

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ol
  (org-link-set-parameters
   "img"
   :follow (lambda (path arg) (org-link-open-as-file path arg))
   :export (lambda (path desc backend cchannel)
             (cond ((eq backend 'html)
                    (format "<img style=\"max-width:80%%;margin:2em\" src=\"data:image/jpg;base64,%s\">"
                            (base64-encode-string
                              (with-temp-buffer
                                (insert-file-contents path)
                                  (buffer-string)))))))))
#+END_SRC

#+RESULTS:

*** enable export to (github) markdown

#+BEGIN_SRC emacs-lisp
(use-package ox-gfm
  :straight t
  :config
  (eval-after-load "org"
    '(require 'ox-gfm nil t))
  )
#+END_SRC

#+RESULTS:
: t

** paul stuff
*** auto-indentation
Setting this variable causes auto-indentation inside org-mode src blocks
#+BEGIN_SRC emacs-lisp
(setq org-src-tab-acts-natively t
      org-src-preserve-indentation nil
      org-edit-src-content-indentation 0)
#+END_SRC

#+RESULTS:
: 0

*** org

#+BEGIN_SRC emacs-lisp
(load-library "org")

(define-key org-mode-map (kbd "C-c o") 'org-open-at-point)
(define-key global-map (kbd "C-C l") 'org-store-link)

(setq org-todo-keyword-faces
      '(("TODO" . org-warning) ("WIP" . "yellow")
        ("CANCELED" . (:foreground "blue" :weight bold))
        ("DONE" . "green")))

(use-package org-bullets
  :straight t
  ;; :hook (org-mode org-bullets-mode)
  :init (progn
          (setq org-ellipsis " ⤵")
          ;; (add-hook org-mode-hook org-bullets-mode)
          ))

(add-hook `org-mode-hook (lambda () (setq inhibit-read-only 1)
                           ;; (auto-insert-mode)
                           (wrap-region-add-wrapper "=" "=")
                           (wrap-region-add-wrapper "~" "~")
                           (wrap-region-add-wrapper "+" "+")
                           (wrap-region-add-wrapper "/" "/")
                           (wrap-region-add-wrapper "*" "*")
                           (wrap-region-add-wrapper "_" "_")
                           (wrap-region-add-wrapper "|" "|")
                           ;; (modify-syntax-entry ?= "\"")
                           (modify-syntax-entry ?* "\"")
                           ;; (modify-syntax-entry ?_ "\"")
                           (modify-syntax-entry ?| "\"")
                           (org-bullets-mode)
                           ))

;; (defadvice syntax-table (before in-src activate)
;;   (if (org-in-src-block-p)
;;       (message "HEERE")
;;     (setq-local syntax-table python-mode-syntax-table)
;;     (setq-local syntax-table (syntax-table))))

;; (define-key org-mode-map "\C-\M-f" '(lambda ()
;;                                      (interactive)
;;                                      (if (org-in-src-block-p)
;;                                          (with-syntax-table
;;                                              python-mode-syntax-table
;;                                            (forward-sexp))
;;                                        (forward-sexp)
;;                                            )))


;; Org babel languages
(org-babel-do-load-languages
 'org-babel-load-languages
 (mapcar (lambda (m) (cons m t))
         '(;; C calc dot
           emacs-lisp ;; gnuplot java js latex
           ;; lisp
           python
           latex
           ;; R racket  not necessary for my purposes
           ;; ruby scheme
           shell sqlite ;; haskell
           sql)))

(org-babel-do-load-languages
 'org-babel-load-languages '((python . t)))

(defun my-org-confirm-babel-evaluate (lang body)
  (not (member lang '("ipython" "python" "emacs-lisp" "sh"))))

(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)

(require 'package)
#+END_SRC

#+RESULTS:
: package

#+RESULTS:
*** syntax table stuff
Let's make sure that syntax table inside src blocks matches the one used for
that language
#+BEGIN_SRC emacs-lisp
(defun org--get-syntax-table-for-src () (interactive)
       (let* ((lang (first (org-babel-get-src-block-info)))
              )
       (cond ((string-equal "emacs-lisp" lang)
              emacs-lisp-mode-syntax-table))
))

#+END_SRC

#+RESULTS:
: org--get-syntax-table-for-src

*** Sql mode related

#+BEGIN_SRC emacs-lisp
;; (package-initialize)
;;   (require 'ob-sql-mode)
#+END_SRC

#+RESULTS:

Code beautifier (see https://www.emacswiki.org/emacs/SqlBeautify)
#+BEGIN_SRC emacs-lisp
(defun sql-beautify-region (beg end)
  "Beautify SQL in region between beg and END."
  (interactive "r")
  (save-excursion
    (shell-command-on-region beg end "anbt-sql-formatter" nil t)))
    ;; change sqlbeautify to anbt-sql-formatter if you
    ;;ended up using the ruby gem

(defun sql-beautify-buffer ()
 "Beautify SQL in buffer."
 (interactive)
 (sql-beautify-region (point-min) (point-max)))

(define-advice org-edit-src-exit (:before (&rest _args) format-sql)
  (when (eq major-mode 'sql-mode)
    (sql-beautify-buffer)))

#+END_SRC

#+RESULTS:
: org-edit-src-exit@format-sql

This is to remove the angle brackets from time stamps exported to html and tex.
Look into more information on beautification [[https://stackoverflow.com/a/33716338/3414663][here]]

#+BEGIN_SRC emacs-lisp
(defun org-export-filter-timestamp-remove-brackets (timestamp backend info)
  "removes relevant brackets from a timestamp"
  (cond
   ((org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string "[<>]\\|[][]" "" timestamp))
   ((org-export-derived-backend-p backend 'html)
    (replace-regexp-in-string "&[lg]t;\\|[][]" "" timestamp))))

(eval-after-load 'ox '(add-to-list
                       'org-export-filter-timestamp-functions
                       'org-export-filter-timestamp-remove-brackets))
#+END_SRC

#+RESULTS:
| org-export-filter-timestamp-remove-brackets |

*** LaTeX macros
This [[   https://www.reddit.com/r/orgmode/comments/7u2n0h/tip_for_defining_latex_macros_for_use_in_both/][idea]] is to make a new org language called latex-macros which allows math
to be exported both to HTML and to LaTeX.

Usage:
#+BEGIN_EXAMPLE
  #+BEGIN_SRC latex-macros
  \newcommand{\Z}{\mathbb{Z}}
  \newcommand{\Hom}{\mathrm{Hom}}
  #+END_SRC
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-src-lang-modes '("latex-macros" . latex))

  (defvar org-babel-default-header-args:latex-macros
    '((:results . "raw")
      (:exports . "results")))

  (defun prefix-all-lines (pre body)
    (with-temp-buffer
      (insert body)
      (string-insert-rectangle (point-min) (point-max) pre)
      (buffer-string)))

  (defun org-babel-execute:latex-macros (body _params)
    (concat
     (prefix-all-lines "#+LATEX_HEADER: " body)
     "\n#+HTML_HEAD_EXTRA: <div style=\"display: none\"> \\(\n"
     (prefix-all-lines "#+HTML_HEAD_EXTRA: " body)
     "\n#+HTML_HEAD_EXTRA: \\)</div>\n"))
#+END_SRC

#+RESULTS:
: org-babel-execute:latex-macros
*** venv functions

To use virtualenv python (needed for keras), you can use

https://emacs.stackexchange.com/questions/24453/weird-shell-output-when-using-ipython-5
https://github.com/jorgenschaefer/elpy/issues/992#issuecomment-249165923
#+BEGIN_SRC emacs-lisp
(setenv "IPY_TEST_SIMPLE_PROMPT" "1")
#+END_SRC

#+RESULTS:
: py-nhbc-poc
*** optimizing
Let's try to write a function that takes python code buffer and appends it to
the shell, instead of executing it and having to wait for it to finish.

#+BEGIN_SRC emacs-lisp
  (defun execute-in-shell (&optional arg _info)
    "Switch to code buffer and display sessiona and execute code there."
    (interactive "P")
    (let ((swap-windows
           (lambda ()
             (let ((other-window-buffer (window-buffer (next-window))))
               (set-window-buffer (next-window) (current-buffer))
               (set-window-buffer (selected-window) other-window-buffer))
             (other-window 1)))
          (info (org-babel-get-src-block-info))
          (org-src-window-setup 'reorganize-frame))
      (save-window-excursion
        (org-babel-switch-to-session arg info))
        (org-edit-src-code)
        (copy-to-buffer  (point-min) (point-max))
        (funcall swap-windows)
        (org-edit-src-exit)
      ))

;; (require 'ob-async)
#+END_SRC

#+RESULTS:
: execute-in-shell
*** pygments
#+BEGIN_SRC emacs-lisp
(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("" "minted"))
(setq org-latex-listings 'minted)

(setq org-src-fontify-natively t)

;; (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((R . t)
;;    (latex . t)))

#+END_SRC

#+RESULTS:
: t
*** exporting
#+BEGIN_SRC emacs-lisp
(setq org-latex-inline-image-rules '(("file" . "\\.\\(pdf\\|jpeg\\|jpg\\|png\\|ps\\|eps\\|tikz\\|pgf\\|svg\\|gif\\)\\'")))
#+END_SRC

#+RESULTS:
: ((file . \.\(pdf\|jpeg\|jpg\|png\|ps\|eps\|tikz\|pgf\|svg\|gif\)\'))

*** ox-extras

might need to do:
=curl https://raw.githubusercontent.com/Fuco1/org-mode/master/contrib/lisp/ox-extra.el >> ~/.emacs.d/lisp/ox-extra.el=

#+BEGIN_SRC emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+END_SRC

#+RESULTS:

** org-ref

bibliography/citations

#+BEGIN_SRC emacs-lisp
;; need this
(use-package pdf-tools
  :straight t)

(use-package org-ref
  :straight t
  )

(setq bibtex-completion-bibliography '(
                                       "~/Documents/literature/references.bib"
                                       )
  bibtex-completion-library-path '("~/Documents/literature/bibtex-pdfs/")
  bibtex-completion-notes-path "~/Documents/literature/notes"
  bibtex-completion-notes-template-multiple-files "* ${author-or-editor}, ${title}, ${journal}, (${year}) :${=type=}:\n"
  ;; bibtex-completion-notes-template-multiple-files "* ${author-or-editor}, ${title}, ${journal}, (${year}) :${=type=}: \n\nSee [[cite:&${=key=}]]\n"

  bibtex-completion-additional-search-fields '(keywords)
  bibtex-completion-display-formats
  '((article       . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${journal:40}")
    (inbook        . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} Chapter ${chapter:32}")
    (incollection  . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${booktitle:40}")
    (inproceedings . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${booktitle:40}")
    (t             . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*}"))
  bibtex-completion-pdf-open-function
  (lambda (fpath)
    (call-process "open" nil 0 nil fpath)))

;; Some org-mode customization
(setq org-src-fontify-natively t
      org-confirm-babel-evaluate nil
      org-src-preserve-indentation t)

(setq org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "bibtex %b"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)

(define-key bibtex-mode-map (kbd "s-b") 'org-ref-bibtex-hydra/body)
(define-key org-mode-map (kbd "C-c ]") 'org-ref-insert-link)

(use-package dash)
(setq org-latex-default-packages-alist
      (-remove-item
       '("" "hyperref" nil)
       org-latex-default-packages-alist))

;; Append new packages
(add-to-list 'org-latex-default-packages-alist '("" "natbib" "") t)
;; (add-to-list 'org-latex-default-packages-alist '("" "apacite" "") t)
(add-to-list 'org-latex-default-packages-alist
       '("linktocpage,pdfstartview=FitH,colorlinks,
linkcolor=blue,anchorcolor=blue,
citecolor=blue,filecolor=blue,menucolor=blue,urlcolor=blue"
         "hyperref" nil)
       t)

;; some requires for basic org-ref usage
;; (require 'org-plus-contrib)
(require 'org-ref)
;; (require 'org-ref-helm)
(require 'org-ref-pdf)
(require 'org-ref-url-utils)

;; setup org-ref
(setq org-ref-notes-function
      (lambda (thekey)
  (let ((bibtex-completion-bibliography (org-ref-find-bibliography)))
    (bibtex-completion-edit-notes
     (list (car (org-ref-get-bibtex-key-and-file thekey)))))))
#+END_SRC

#+RESULTS:
| lambda | (thekey) | (let ((bibtex-completion-bibliography (org-ref-find-bibliography))) (bibtex-completion-edit-notes (list (car (org-ref-get-bibtex-key-and-file thekey))))) |



*** biblio.el

#+BEGIN_SRC emacs-lisp
(use-package biblio
  :straight t)
#+END_SRC

#+RESULTS:

*** org-ref glossary

#+BEGIN_SRC emacs-lisp
(add-hook 'org-export-before-parsing-hook 'org-ref-glossary-before-parsing)
(add-hook 'org-export-before-parsing-hook 'org-ref-acronyms-before-parsing)
#+END_SRC

#+RESULTS:
| org-ref-acronyms-before-parsing | org-ref-glossary-before-parsing | org-attach-expand-links |

** org-download: insert screenshots/imgs into org files

#+BEGIN_SRC emacs-lisp
(defun get-image-directory (fpath)
  (let* ((dir (file-name-directory fpath))
         (base (file-name-base fpath)))
    (concat dir "images/" base)))

(defun jpj/set-org-download-image-dir ()
  (let* ((fpath (get-current-fpath))
         (image-dir (if fpath (get-image-directory fpath) nil)))
    (when image-dir
      (setq-local org-download-image-dir image-dir
                  org-download-heading-lvl nil))))

(use-package org-download
  :straight t
  :config
  (setq org-download-image-dir nil
        org-download-heading-lvl nil
        org-download-method 'directory)
  (add-hook 'org-mode-hook 'jpj/set-org-download-image-dir)
)
#+END_SRC

#+RESULTS:
: t

** org-reveal: export org to reveal.js slides

#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
  :straight t)
#+END_SRC

#+RESULTS:

* scratch

=M-x scratch= to create new scratch buffer.

#+BEGIN_SRC emacs-lisp
(use-package scratch
  :straight t)
#+END_SRC

#+RESULTS:

* shell

make sure shell opens in current window

#+BEGIN_SRC emacs-lisp
(add-to-list 'display-buffer-alist
             '("^\\*shell\\*$" . (display-buffer-same-window)))

#+END_SRC

switch between bash and zsh

#+BEGIN_SRC emacs-lisp
(defun set-bash () (interactive) (setq explicit-shell-file-name "/bin/bash"))
(defun set-zsh () (interactive)
       (setq explicit-shell-file-name "/bin/zsh")
       (setq explicit-zsh-args '("--interactive" "--login"))
       (setq comint-process-echoes 0)
       (add-hook 'comint-output-filter-functions #'comint-osc-process-output)
       (shell-dirtrack-mode -1)
       (dirtrack-mode -1)
       )

;; set zsh as default
(set-zsh)
nil
#+END_SRC

#+RESULTS:

enable command substitution
(https://www.masteringemacs.org/article/shell-comint-secrets-history-commands)

#+BEGIN_SRC emacs-lisp
(define-key shell-mode-map (kbd "SPC") 'comint-magic-space)
#+END_SRC

#+RESULTS:
: comint-magic-space

* javascript
** auto-format

#+BEGIN_SRC emacs-lisp
(use-package js-format
  :straight t)
(eval-after-load 'js-mode
  (add-hook 'js-mode-hook
            (lambda()
              (js-format-setup "airbnb")))
  )
(custom-set-variables
 '(js-auto-format-command "prettier")
 '(js-auto-format-command-args "--write --single-quote --no-semi"))


(add-hook `js2-mode-hook (lambda ()
                           (global-set-key (kbd "C-c C-v") #'js-format-buffer)))
#+END_SRC

#+RESULTS:
| lambda | nil | (global-set-key (kbd C-c C-v) #'js-format-buffer) |

#+RESULTS:
: scss-mode

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(defun my/activate-tide-mode ()
  "Use hl-identifier-mode only on js or ts buffers."
  (when (and (stringp buffer-file-name)
             (string-match "\\.[tj]sx?\\'" buffer-file-name))
    (tide-setup)
    (tide-hl-identifier-mode)))

;; (use-package tide
;;    :hook (web-mode . my/activate-tide-mode)
;;    :ensure t)
(add-hook 'rjsx-mode-hook 'prettier-js-mode)
#+END_SRC

#+RESULTS:
| prettier-js-mode |

#+BEGIN_SRC emacs-lisp
;; (defun my-tide-show-symbol-info ()
;;   "Show info about the current symbol in a temporary buffer."
;;   (interactive)
;;   (let ((response tide-command:quickinfo `(:file ,buffer-file-name :pos ,(tide-current-position)))))
;;     (tide-on-response-success response
;;       (let* ((quickinfo (tide-parse-response response))
;;              (display-string (tide-quickinfo-display-string quickinfo)))
;;         (with-output-to-temp-buffer "*My Tide Info*"
;;           (princ display-string))))))

;; (global-set-key (kbd "C-c C-v") 'my-tide-show-symbol-info)
#+END_SRC

#+RESULTS:
: my-tide-show-symbol-info

* reformatter

#+BEGIN_SRC emacs-lisp
(use-package reformatter
  :straight t)
#+END_SRC

#+RESULTS:

* python

#+BEGIN_SRC emacs-lisp
(use-package python
  :straight t
  :mode ("\\.py\\'" . python-mode)
  :interpreter ("python" . python-mode))

(defun my/python-mode-hook ()
  (setq python-shell-interpreter "ipython"
        python-shell-interpreter-args "--simple-prompt -i")
  (modify-syntax-entry ?\( ".")
  (modify-syntax-entry ?\) ".")
  (setq forward-sexp-function nil)
  )

(add-hook 'python-mode-hook 'my/python-mode-hook)

nil
#+END_SRC

#+RESULTS:

** python for freecad

#+BEGIN_SRC emacs-lisp
(defun my/python-for-freecad ()
  (interactive)
  (setq-local python-shell-interpreter "/usr/local/Caskroom/freecad/0.21.2/FreeCAD.app/Contents/Resources/bin/python"
              python-shell-interpreter-args "")
  )
#+END_SRC

#+RESULTS:
: my/python-for-freecad

** smartparens

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :straight t
  :config
  (setq sp-autoinsert-pair nil))


(defun my/smartparens-python-hook ()
  (smartparens-mode)
  ;; do sp keybindings: sp-backward-sexp and sp-forward-sexp
  (local-set-key (kbd "C-M-f") 'sp-forward-sexp)
  (local-set-key (kbd "C-M-b") 'sp-backward-sexp)
  )
(add-hook 'python-mode-hook 'my/smartparens-python-hook)

nil
#+END_SRC

#+RESULTS:

** ruff

#+BEGIN_SRC emacs-lisp
(use-package flymake-ruff
  :straight (flymake-ruff
             :type git
             :host github
             :repo "erickgnavar/flymake-ruff")
  :hook (eglot-managed-mode . flymake-ruff-load)
        (python-mode . flymake-ruff-load))

(use-package ruff
  :straight (ruff :host github
                          :repo "scop/emacs-ruff-format")
  :hook (python-mode . ruff-format-on-save-mode))

nil
#+END_SRC

#+RESULTS:

** autoformatting using black

#+BEGIN_SRC emacs-lisp
(use-package blacken
  :straight t
  :config
  (setq blacken-line-length 79)
  (setq blacken-executable "/Users/jeroen/.virtualenvs/py3.8/bin/black")
  ;; (add-hook 'python-mode-hook 'blacken-mode 'too-long-lines-mode)
  )

(define-advice org-edit-src-exit (:before (&rest _args) format-python)
  "Run `blacken-buffer' when leaving an org-mode Python source block."
  (when (eq major-mode 'python-mode)
    (blacken-buffer)))
#+END_SRC

#+RESULTS:
: org-edit-src-exit@format-python

** xsh
#+BEGIN_SRC emacs-lisp
(push '("\\.xsh$" . python-mode) auto-mode-alist)
nil
#+END_SRC

** pipenv

#+BEGIN_SRC emacs-lisp
(push '("/Pipfile$" . conf-mode) auto-mode-alist)
(push '("/Pipfile.lock$" . js2-mode) auto-mode-alist)
nil
#+END_SRC

** virtualenv

#+BEGIN_SRC emacs-lisp
(use-package virtualenvwrapper
  :straight t
  :config
  (venv-initialize-interactive-shells) ;; if you want interactive shell support
  (venv-initialize-eshell)             ;; if you want eshell support
  ;; note that setting `venv-location` is not necessary if you
  ;; use the default location (`~/.virtualenvs`), or if the
  ;; the environment variable `WORKON_HOME` points to the right place
  (setq venv-location "~/.virtualenvs/")
  :hook (python-mode . venv-projectile-auto-workon)
)
#+END_SRC

#+RESULTS:
: t

** info

#+BEGIN_SRC emacs-lisp
  (require 'info-look)

  (info-lookup-add-help
   :mode 'python-mode
   :regexp "[[:alnum:]_]+"
   :doc-spec '(("(python)Index" nil "")))
#+END_SRC

#+RESULTS:

** ipython

#+BEGIN_SRC emacs-lisp
(define-key python-mode-map (kbd "DEL") nil)

(fset 'ipython-cpaste
   (kmacro-lambda-form [?\M-> ?% ?c ?p ?a ?s ?t ?e return ?\M-x ?y ?a ?n ?k ?\C-m return ?- ?- return] 0 "%d"))

(define-key inferior-python-mode-map (kbd "C-M-y") 'ipython-cpaste)
(define-key shell-mode-map (kbd "C-M-y") 'ipython-cpaste)
#+END_SRC

#+RESULTS:
: ipython-cpaste


** pygen (unused)

#+BEGIN_SRC emacs-lisp
;; (use-package pygen
;;   :ensure t)
;; (add-hook 'python-mode-hook 'pygen-mode)
#+END_SRC

#+RESULTS:
| pygen-mode | (closure (t) nil (setq imenu-create-index-function py--imenu-create-index-function) (setq indent-tabs-mode py-indent-tabs-mode)) | (lambda nil No eldoc for remote files (let ((name (buffer-file-name))) (when (and name (> (length name) 5) (string= /ssh: (substring name 0 5))) (eldoc-mode -1)))) | elpy-mode | (lambda nil No eldoc for remote files (let ((name (buffer-file-name))) (if (and name (> (length name) 5) (string= /ssh: (substring name 0 5))) (progn (eldoc-mode -1))))) | blacken-mode |

** docstrings (python-docstring)

=M-q= messes up docstrings formatting. luckily, someone wrote a package which
improves this behaviour.

#+BEGIN_SRC emacs-lisp
(use-package python-docstring
  :straight t)

(add-hook 'python-mode-hook 'python-docstring-mode)
#+END_SRC

#+RESULTS:
| python-docstring-mode | (closure (t) nil (setq imenu-create-index-function py--imenu-create-index-function) (setq indent-tabs-mode py-indent-tabs-mode)) | (lambda nil No eldoc for remote files (let ((name (buffer-file-name))) (if (and name (> (length name) 5) (string= /ssh: (substring name 0 5))) (progn (eldoc-mode -1))))) | blacken-mode |

** pytest

#+BEGIN_SRC emacs-lisp
(defun my-python-pytest-setup ()
    (when (and (boundp 'tramp-virtualenv-dir)
               tramp-virtualenv-dir)
      ;; Set python-pytest-executable to use the pytest in the virtual environment
      (setq-local python-pytest-executable
                  (concat tramp-virtualenv-dir "/bin/pytest"))))

(use-package python-pytest
  :straight t
  :config
  (add-hook 'python-mode-hook #'my-python-pytest-setup)
  (bind-keys* :map python-mode-map
            ((kbd "C-c y") . python-pytest-dispatch)
            )
  )
#+END_SRC

#+RESULTS:
: t

** elpy

#+BEGIN_SRC emacs-lisp
;; (use-package elpy
;;   :straight t
;;   :init
;;   (elpy-enable))
#+END_SRC

#+RESULTS:


* highlight syntax errors in json

This requires =jsonlint=. Install with =npm install jsonlint -g=.

#+BEGIN_SRC emacs-lisp
(delete 'flycheck-disabled-checkers "json-jsonlist")
(use-package flycheck
  :ensure t)
(flycheck-add-mode 'json-jsonlint 'json-mode)
(add-hook 'json-mode-hook 'flycheck-mode)
#+END_SRC

#+RESULTS:
| flycheck-mode |

* emacs-dashboard
the =dashboard= package changes the splash screen into something useful.

enable it:
#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :ensure t
  :init
  (progn
    (setq dashboard-items nil)
    (setq dashboard-banner-logo-title "jpjmacs")
    (setq dashboard-startup-banner "~/.emacs.d/araki_banner.png")
    (setq dashboard-set-navigator nil)
    (setq dashboard-set-footer nil)
    )
  :config
  (dashboard-setup-startup-hook))
#+END_SRC

#+RESULTS:
: t
* focused editing

** olivetti

olivetti provides a centered buffer.

#+BEGIN_SRC emacs-lisp
(use-package olivetti
  :ensure t
  :diminish
  :config
  (setq olivetti-body-width 0.7)
  (setq olivetti-minimum-body-width 100)
  (setq olivetti-recall-visual-line-mode-entry-state t))
#+END_SRC

#+RESULTS:
: t

** typewrite

some functions which combine various focused editing packages.

#+BEGIN_SRC emacs-lisp
(defun typewrite ()
  (interactive)
  (delete-other-windows)
  (olivetti-mode))

(defun untypewrite ()
  (interactive)
  (olivetti-mode))
#+END_SRC

#+RESULTS:
: untypewrite

* list all URLs in a pdf

#+BEGIN_SRC emacs-lisp
(defun list-urls-in-pdf ()
  "Lists all URLs in pdf file in current buffer."
  (interactive)
  (let* ((fpath (get-current-fpath))
         (buffer (generate-new-buffer "*pdf-urls*"))
         (cmd
          (s-join ""
                  (list "~/.virtualenvs/base/bin/pdfx -v '" fpath "' | sed -n 's/^- \\(http\\)/\\1/p'"))))
    (shell-command cmd buffer)
    (switch-to-buffer buffer)))
#+END_SRC

#+RESULTS:
: list-urls-in-pdf

* windows os

run bash on windows:

#+BEGIN_SRC emacs-lisp
(defun shell-on-windows ()
  (let ((explicit-shell-file-name "C:/Windows/System32/bash.exe"))
    (shell)))
#+END_SRC

#+RESULTS:
: shell-on-windows

* mode-line
** minor modes

diminish.el (re)moves the text some minor modes add to the minor lighter text
in mode-line.

#+BEGIN_SRC emacs-lisp
;; (use-package diminish
;;   :straight t
;;   :config
;;   (diminish 'projectile-mode)
;;   (diminish 'auto-fill-mode))
#+END_SRC

however, i'd like to whitelist minor modes that /are/ allowed instead of having
to blacklist all i /don't/ want. for that, there exists =rich-minority=:

#+BEGIN_SRC emacs-lisp
(use-package rich-minority
  :straight t
  :config
  ;; (setq rm-blacklist "Projectile.*")
  (setq rm-whitelist-regexps
        '(
          "mc:*"
          " Def"
          "©"
          ))
  (setq rm-whitelist (mapconcat 'identity rm-whitelist-regexps "\\|"))
  ;; (setq rm-whitelist
  ;;     (format "^ \(%s\)$"
  ;;             (mapconcat #'identity
  ;;                        rm-whitelist-regexps
  ;;                        "\\|")))
  (rich-minority-mode 1))
#+END_SRC

#+RESULTS:
: t

** hide mode-line, put at header-line spot

#+BEGIN_SRC emacs-lisp
;; status-icon to the left of filename
(defun render-mode-line-status-icon (read-only modified)
  (if read-only
      ""
    (if modified
        " ●"
        " ○"
      )))
(defun render-mode-line-remote (remote)
  (if remote
      " @"
    ""))


;; mode-line section on left of screen
(setq mode-line-left-section
      (list
       ;; day and time
       ;; '(:eval (propertize (format-time-string " %b %d %H:%M ")
       ;;                     'face 'font-lock-builtin-face))

       ;; buffer status icon (dot)
       '(:eval (render-mode-line-status-icon buffer-read-only (buffer-modified-p)))
       ;; (render-mode-line-remote mode-line-remote)

       ;; the buffer name; the file name as a tool tip
       '(:eval (propertize " %b "
                           'help-echo (buffer-file-name)))

       ;; relative position, size of file
       ;; " ["
       ;; (propertize "%p" 'face 'font-lock-constant-face) ;; % above top
       ;; "/"
       ;; (propertize "%I" 'face 'font-lock-constant-face) ;; size
       ;; "] "
       ))

;; mode-line section on right of screen
(setq mode-line-right-section
      (list
       ;; git branch
       '(:eval (if vc-mode
                   (propertize (substring vc-mode 5)
                           'face 'font-lock-comment-face)
                   ""))

       ;; line and column
       " [" ;; '%02' to set to 2 chars at least; prevents flickering
       (propertize "%02l" 'face 'font-lock-comment-face) ":"
       (propertize "%02c" 'face 'font-lock-comment-face)
       "] "
       ;; (propertize org-mode-line-string 'face '(:foreground "#5DD8FF"))

       ;; the current major mode
       (propertize " %m" 'face 'font-lock-comment-face)
       " "
       ;; org timer
       ;; '(:eval (propertize
       ;;          (if org-timer-start-time
       ;;              org-timer-mode-line-string
       ;;            nil)
       ;;          'face 'font-lock-comment-face))
       ;; rich-minority minor modes
       rm--mode-line-construct
       "  "
       ))

(defun mode-line-render ()
  (append (append mode-line-left-section
                  (list
                   ;; function to right-justify part of modeline
                   ;; by filling center with spaces
                   '(:eval (s-repeat
                            (- (+ (window-total-width) 0)
                               (+
                                (length (format-mode-line mode-line-right-section))
                                (length (format-mode-line mode-line-left-section))))
                            " "))
                   )
                  mode-line-right-section)))


;; actually render the mode-line
;; (setq-default mode-line-format (mode-line-render))

;; move modeline to the top of the buffer
(setq-default header-line-format (mode-line-render))
;; (setq-default mode-line-format'(""))
;; hide empty mode-line
(setq-default mode-line-format nil)

;; reduce height of empty mode-line
(set-face-attribute 'mode-line nil :foreground "white" :background nil :box nil :overline "#1e212e")
(set-face-attribute 'mode-line-inactive nil :background nil :box nil :foreground "#232635" :overline "#1e212e")

(set-face-attribute 'vertical-border nil :background nil :foreground "#676E95")

;; decorate header-line
(set-face-attribute 'header-line nil
                    :background "#1c1f2b"
                    :foreground "#EEFFFF"
                    :box '(:line-width 5 :color "#1c1f2b")
                    :overline nil
                    :underline nil)
#+END_SRC

#+RESULTS:

* powerthesaurus in emacs

#+BEGIN_SRC emacs-lisp
(use-package powerthesaurus
  :straight t
  :config
  (defhydra hydra-powerthesaurus (:color blue :hint nil)
    "
    Powerthesaurus:
    ^Synonyms^ ^Related^ ^Antonyms^ ^Definitions^
    ----------------------------------------------
    s: r: a: d:
    "
    ("s" powerthesaurus-lookup-synonyms-dwim)
    ("r" powerthesaurus-lookup-related-dwim)
    ("a" powerthesaurus-lookup-antonyms-dwim)
    ("d" powerthesaurus-lookup-definitions-dwim))

  (bind-key* "s-p" 'hydra-powerthesaurus/body)
  )
#+END_SRC

#+RESULTS:
: t

* google-translate

google translate in emacs.

#+BEGIN_SRC emacs-lisp
(use-package google-translate
  :straight t
  :config
  (setq google-translate-default-source-language "nl")
  (setq google-translate-default-target-language "en")
  (bind-key* "C-c t" 'google-translate-smooth-translate)
  (setq google-translate-translation-directions-alist
      '(("nl" . "en") ("en" . "nl") ("en" . "es") ("es" . "en")))
  )

(bind-key* "C-c t" 'google-translate-smooth-translate)
#+END_SRC

#+RESULTS:
: google-translate-smooth-translate

* maak-belachelijk
#+BEGIN_SRC emacs-lisp
(defun maak-belachelijk ()
  (interactive)
  (let ((initial-end (region-end)))
  (if (use-region-p)
      (save-excursion
        (goto-char (region-beginning))
        (while (<= (point) initial-end)
          (message (format "%s"(point)))
          (goto-char (+
                      (+ (floor (* 3 (/ (abs (random)) (float most-positive-fixnum)))) 1)
                      (point)))
          (if (<= (point) initial-end)
                  (call-interactively 'upcase-char)))))))
#+END_SRC

#+RESULTS:
: maak-belachelijk

* macros

#+BEGIN_SRC emacs-lisp
(fset 'shell-last-python-script
   (kmacro-lambda-form [?\M-r ?p ?y ?t ?h ?o ?n ?  return] 0 "%d"))

(bind-keys* :map shell-mode-map
            ((kbd "C-M-r") . shell-last-python-script)
            )
#+END_SRC

#+RESULTS:
: shell-last-python-script

* free-keys

find free keys

#+BEGIN_SRC emacs-lisp
(use-package free-keys
  :straight t
  :config
  (setq free-keys-modifiers '("" "C" "M" "C-M" "s")))
#+END_SRC

#+RESULTS:
: t

* pandoc-mode

a mode of interacting with pandoc in emacs.

#+BEGIN_SRC emacs-lisp
(use-package pandoc-mode
  :straight t)
#+END_SRC

#+RESULTS:

* terraform-mode

major mode for editing .tf files

#+BEGIN_SRC emacs-lisp
(use-package terraform-mode
  :straight t)
#+END_SRC

#+RESULTS:

* devdocs

#+BEGIN_SRC emacs-lisp
(use-package devdocs
  :straight t
  :config
  (bind-key* "C-<backspace> d" 'devdocs-lookup)
  (add-hook 'python-mode-hook
          (lambda () (setq-local devdocs-current-docs '("python~3.12" "pandas~1")))))
#+END_SRC

#+RESULTS:
: t

* xref and tags

#+BEGIN_SRC emacs-lisp
;; turn off the prompting for tags file
(setq xref-prompt-for-identifier nil)
#+END_SRC

* copilot

#+BEGIN_SRC emacs-lisp
(use-package copilot
  :straight (:host github :repo "zerolfx/copilot.el" :files ("dist" "*.el"))
  :ensure t
  :config
  (add-hook 'python-mode-hook 'copilot-mode)
  (add-hook 'web-mode-hook 'copilot-mode)
  (add-hook 'lisp-mode-hook 'copilot-mode)
  (setq copilot-major-mode-alist
        (append copilot-major-mode-alist
                '((yaml-ts-mode . "yaml")
                  (bash-ts-mode . "bash")
                  (js-ts-mode . "javascript")
                  (typescript-ts-mode . "typescript")
                  (json-ts-mode . "json")
                  ;; (css-ts-mode . "css")
                  (python-mode . "python")
                  (web-mode . "html"))))
  (bind-key* "M-/" 'copilot-accept-completion)
  (bind-key* "C-M-/" 'copilot-accept-completion-by-line)
  )
#+END_SRC

#+RESULTS:
: t

* vdirel

contact manager in emacs. requires =vdirsyncer= to be set up.

#+BEGIN_SRC emacs-lisp
;; (use-package vdirel
;;   :straight t
;;   :config
;;   (setq vdirel-repository "~/.contacts")
;;   )
#+END_SRC

#+RESULTS:
: t

* swift

#+BEGIN_SRC emacs-lisp
(use-package swift-mode
  :straight t)
#+END_SRC

#+RESULTS:

* kotlin

#+BEGIN_SRC emacs-lisp
(use-package kotlin-mode
  :straight t)
#+END_SRC

#+RESULTS:

* my personal lil hydra

#+BEGIN_SRC emacs-lisp
(defun jpj/org-toggle-between-list-paragraph ()
  (interactive)
  ;; Check if the current line is a list item.
  (if (org-in-item-p)
      ;; Convert from list item to paragraph.
      (let ()
        (unfill-paragraph) ;; Assuming this unfills the entire list/paragraph.
        ;; Remove "- " from the beginning of the line.
        (goto-char (line-beginning-position))
        (when (looking-at "- ")
          (delete-region (line-beginning-position) (+ (line-beginning-position) 2)))
        (save-excursion
          (goto-char (line-end-position))
          (unless (and (eq (char-after) ?\n) (eq (char-after (1+ (point))) ?\n))
            (insert "\n")))
        )
    ;; Convert from paragraph to list item.
    (let ()
      (unfill-paragraph) ;; Unfill the paragraph first to ensure it's a single line.
      ;; Add "- " at the beginning of the line.
      (goto-char (line-beginning-position))
      (insert "- ")))
  ;; Reformat the text to adhere to Org's fill settings.
  (org-fill-paragraph))


(defun org-define-nyt-link (&optional complete-file)
  "Prompt for a link, then insert it with 'nyt' as the visible text."
  (interactive "P")
  (let ((url (read-string "Enter URL: ")))
    (org-insert-link complete-file url "nyt")))

(defhydra hydra-personal (:color blue :hint nil)
  "
^Personal Macros/Things^
-------------------------------
_n_ : org-define-nyt-link
_x_ : copy-unfilled-region
_l_ : jpj/org-toggle-between-list-paragraph
_s_ : jpj/add-shadcn-ui-component
_o_ : olivetti-mode
_u_ : org-unindent-buffer
"
  ("n" org-define-nyt-link)
  ("x" copy-unfilled-region)
  ("l" jpj/org-toggle-between-list-paragraph)
  ("s" jpj/add-shadcn-ui-component)
  ("o" olivetti-mode)
  ("u" org-unindent-buffer)
)

(bind-key* "s-g" 'hydra-personal/body)
#+END_SRC

#+RESULTS:
: hydra-personal/body

* gptel

#+BEGIN_SRC emacs-lisp
(use-package gptel
  :straight (:host github :repo "karthink/gptel" :branch "4c0583b2bd6557a09d66dfec84bab776242d0848")
  :config
  (require 'gptel-curl)
  (require 'gptel-openai)
  (require 'gptel-anthropic)

  (setq-default gptel-default-mode 'org-mode)
  (setq gptel-directives '(
                          (default . "You are a large language model living in Emacs and a helpful assistant. Respond concisely. When asked a code question, you should choose whether the user wants the relevant snippet only, or the entire implementation. In both cases, first give the code with minimal comments, and only explain it after. When giving a snippet, really only provide the relevant bit of code that the user needs to know in order to proceed! IMPORTANT: in code src blocks remember to not confuse Markdown-to-Org things: like don't use = instead of ` in javascript code, etc.")
                          (programming . "You are a large language model and a careful programmer. Provide code and only code as output without any additional text, prompt or note.")
                          (writing . "You are a large language model and a writing assistant. Respond concisely.")
                          (chat . "You are a large language model and a conversation partner. Respond concisely.")
                          ))

  ;; claude

  ;; (gptel-make-anthropic "claude"
  ;;   :stream t :key gptel-claude-3-api-key)

  (setq
   gptel-model "claude-3-5-sonnet-20241022"
   gptel-backend (gptel-make-anthropic "claude"
                   :stream t :key gptel-claude-3-api-key :models '("claude-3-5-sonnet-20241022")))
  (setq my/gptel-api-key-label "claude-private-mode")

  ;; gpt

  ;; (setq-default gptel-model "gpt-4-turbo")
  ;; (setq my/gptel-api-key-label "tsf-mode")


  (defun my/set-gptel-api-key-label ()
    (interactive)
    (setq my/gptel-api-key-label (completing-read "set api key: " gptel-api-key-alist)))

  ;; Function to dynamically set the gptel API key based on label
  (defun gptel-select-api-key (label)
    "Select the API key based on the given LABEL."
    (interactive "sEnter API key label: ")
    (let ((key (cdr (assoc label gptel-api-key-alist))))
      (if key
          (setq gptel-api-key key)
        (error "API key for label '%s' not found" label))))

  (defun my/on-gptel-mode ()
      ;; (font-lock-mode -1)
      (visual-line-mode t)
      )

  (add-hook 'gptel-mode-hook 'my/on-gptel-mode)

  ;; Entry point for chat sessions
  (defun chat ()
    "Start a new chat session with the specified settings."
    (interactive)
    (gptel-select-api-key my/gptel-api-key-label)
    (gptel "*llm*" nil nil t)
    (auto-fill-mode 0)
    (visual-line-mode t))

  ;; Entry point for gpt-screen function
  (defun gpt-screen ()
    "Take the contents of each buffer visible on screen and start a new gptel session."
    (interactive)
    (let ((content "*** Here is some code I am working on:\n\n"))
      ;; Concatenate buffer contents
      (dolist (win (window-list))
        (let* ((buf (window-buffer win))
               (buf-name (buffer-name buf)))
          (with-current-buffer buf
            (setq content (concat content
                                  "**** " buf-name "\n\n#+BEGIN_EXAMPLE\n"
                                  (buffer-string) "\n#+END_EXAMPLE\n\n")))))
      (setq content (concat content
                                  "*** now please answer the following question:\n\n"
))
      ;; Start a new gptel session with the concatenated content
      (gptel-select-api-key my/gptel-api-key-label)
      (gptel (generate-new-buffer-name "*llm screen*") nil content t))
    (auto-fill-mode 0)
    (visual-line-mode t))

  (defun gpt-screen-visible ()
  "Take the contents of each visible part of buffers on screen and start a new gptel session."
  (interactive)
  (let ((content "*** Here is some code I am working on:\n\n"))
    ;; Concatenate visible buffer contents
    (dolist (win (window-list))
      (let* ((buf (window-buffer win))
             (buf-name (buffer-name buf))
             (start (window-start win))
             (end (window-end win t))) ; 't' for fully updated window-end position
        (with-current-buffer buf
          (setq content (concat content
                                "**** " buf-name "\n\n (note: potentially truncated.)\n#+BEGIN_EXAMPLE\n"
                                (buffer-substring start end) "\n#+END_EXAMPLE\n\n")))))
    (setq content (concat content
                          "*** now please answer the following question:\n\n"))
    ;; Start a new gptel session with the concatenated content
    (gptel-select-api-key my/gptel-api-key-label)
    (gptel (generate-new-buffer-name "*gpt screen visible*") nil content t))
  (auto-fill-mode 0)
  (visual-line-mode t))

  (defun gpt-screen-current ()
  "Process the current buffer and start a new gptel session."
  (interactive)
  (let ((content (format "*** Here is a buffer I am working on:\n\n**** %s\n\n#+BEGIN_EXAMPLE\n%s\n#+END_EXAMPLE\n\n*** now please answer the following question:\n\n" (buffer-name) (buffer-string))))
    (gptel-select-api-key my/gptel-api-key-label)
    (gptel (generate-new-buffer-name "*gpt current*") nil content t))
  (auto-fill-mode 0)
  (visual-line-mode t))

(defun gpt-screen-current-visible ()
  "Process the visible part of the current buffer and start a new gptel session."
  (interactive)
  (let* ((win (selected-window))
         (content (format "*** Here is the visible part of the current buffer:\n\n**** %s\n\n (note: potentially truncated.)\n#+BEGIN_EXAMPLE\n%s\n#+END_EXAMPLE\n\n*** now please answer the following question:\n\n" (buffer-name) (buffer-substring (window-start win) (window-end win t)))))
    (gptel-select-api-key my/gptel-api-key-label)
    (gptel (generate-new-buffer-name "*gpt current visible*") nil content t))
  (auto-fill-mode 0)
  (visual-line-mode t))


  (defhydra hydra-gptel (:color blue :hint nil)
  "
  ^gptel macro^
  -------------------------------
  _c_ : chat
  _s_ : gpt-screen
  _v_ : gpt-screen-visible
  _k_ : my/set-gptel-api-key-label
  _j_ : gpt-screen-current
  _n_ : gpt-screen-current-visible
  "
  ("c" chat)
  ("s" gpt-screen)
  ("v" gpt-screen-visible)
  ("k" my/set-gptel-api-key-label)
  ("j" gpt-screen-current)
  ("n" gpt-screen-current-visible)
  ("q" nil "quit" :color blue)
)

  (bind-key* "s-l" 'hydra-gptel/body)
)


#+END_SRC

#+RESULTS:
: t

to authenticate, add this to your .authinfo(.gpg):

#+BEGIN_EXAMPLE
machine api.openai.com login apikey password <key>
#+END_EXAMPLE

key from: https://platform.openai.com/api-keys

* embark

#+BEGIN_SRC emacs-lisp
(defun my/swiper-with-embark-target (target)
  "Invoke swiper with the current Embark target as the initial input."
  (swiper target))

(use-package embark
  :straight t

  :bind
  (("s-r" . embark-act)         ;; pick some comfortable binding
   ("C-s-r" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  ;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
  ;; strategy, if you want to see the documentation from multiple providers.
  (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

  :config
  (dolist (map (list embark-region-map
                     embark-identifier-map
                     embark-symbol-map
                     embark-general-map
                     embark-buffer-map
                     embark-file-map))
    (define-key map (kbd "s") 'my/swiper-with-embark-target)
    (define-key map (kbd "g") 'consult-ripgrep)
    (define-key map (kbd "/") 'embark-gptel-rewrite-region))


  ;; Hide the mode line of the Embark live/completions buffers
  ;; (add-to-list 'display-buffer-alist
  ;;              '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
  ;;                nil
  ;;                (window-parameters (mode-line-format . none))))
)

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :straight t ; only need to install it, embark loads it after consult if found
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC

#+RESULTS:
| embark-consult--upgrade-markers | consult-preview-at-point-mode |

* jpj-python

#+BEGIN_SRC emacs-lisp
(defun jpj/py/search-python-symbol-definitions (input)
  "Search for Python symbol definitions matching INPUT in the project."
  (let* ((project-root (projectile-project-root))
         (all-files (projectile-current-project-files))
         (py-files (cl-remove-if-not
                    (lambda (file) (string-suffix-p ".py" file))
                    all-files))
         (search-regexp (concat "^\\(?:async \\)?def " "\\(" input "\\sw*\\).*$"            ; Match function definitions
        "\\|^class " "\\(" input "\\sw*\\).*$"       ; Match class definitions
        "\\|^\\(" input "\\sw*\\) =.*$"           ; Match variable assignments
        "\\|\\bfrom \\S+ import \\(?:\\S+ \\)*\\(" input "\\sw*\\).*$")  ; Match from-imports
                        )
         (matches '()))
    (dolist (file py-files matches)
      (with-temp-buffer
        (insert-file-contents (concat project-root file))
        (goto-char (point-min))
        (while (re-search-forward search-regexp nil t)
          (let ((symbol-match (match-string 0))
                (full-symbol (or (match-string 1) (match-string 2) (match-string 3) (match-string 4) (match-string 5))))
            ;; Check if it's an import statement and the file is __init__.py
            (when (or (not (or (match-string 4) (match-string 5))) ; Not an import statement
                      (string-match-p "__init__.py$" file))       ; Or it's an import in __init__.py
              (push (cons (concat file " - " full-symbol ": " symbol-match) file) matches))))))))

(defun jpj/py/format-import-statement (file symbol)
  "Format an import statement from FILE and SYMBOL."
  (let* (
         ;; (project-root (projectile-project-root))
         ;; (relative-path (file-relative-name file project-root))
         (relative-path file)
         (module-path (replace-regexp-in-string "/" "." (file-name-sans-extension relative-path)))
         (module-path (replace-regexp-in-string ".__init__$" "" module-path)))
    (format "from %s import %s\n" module-path symbol)))

(defun jpj/py/insert-at-top-after-comments (text)
  "Insert TEXT at the top of the file, after any comments."
  (save-excursion
    (goto-char (point-min))
    (while (looking-at-p "#")
      (forward-line))
    (insert text)))

(defun jpj/py/insert-python-import-interactive ()
  "Interactively insert a Python import statement, using the word at point or the selected region as the initial input, if available."
  (interactive)
  (let ((initial-input (if (use-region-p)
                           (buffer-substring-no-properties (region-beginning) (region-end))
                         (thing-at-point 'sexp))))
    (ivy-read "Symbol: " (lambda (input)
                           (or (ivy-more-chars)
                               (jpj/py/search-python-symbol-definitions input)))
              :dynamic-collection t
              :initial-input initial-input
              :require-match t
              :action (lambda (x)
                        (let* ((split-selection (split-string x " - "))
                               (file (car split-selection))
                               (symbol (car (split-string (nth 1 split-selection) ": ")))
                               (import-statement (jpj/py/format-import-statement file symbol)))
                          (jpj/py/insert-at-top-after-comments import-statement)
                          ))
              :caller 'jpj/py/insert-python-import-interactive)))

(bind-key* "s-i" 'jpj/py/insert-python-import-interactive)
#+END_SRC

#+RESULTS:
: jpj/py/insert-python-import-interactive

* zoxide

needs a =brew install zoxide= as well.

#+BEGIN_SRC emacs-lisp
(use-package zoxide
  :straight t
  :bind (("s-f" . zoxide-find-file)
         ))
#+END_SRC

#+RESULTS:
: zoxide-find-file

* writeroom-mode

#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
  :straight t)
#+END_SRC

#+RESULTS:

* improvements

#+BEGIN_SRC emacs-lisp
;; Optimize shell mode
(defun my-optimize-shell-mode ()
  (setq-local comint-move-point-for-output 'others)
  ;; Adjust or disable font-lock to improve performance
  ;; (font-lock-mode -1)
  )

(add-hook 'shell-mode-hook 'my-optimize-shell-mode)

;; Optimize inferior-python-mode
(defun my-optimize-inferior-python-mode ()
  (setq-local comint-move-point-for-output 'others)
  ;; Adjust or disable font-lock to improve performance
  ;; (font-lock-mode -1)
  )

(add-hook 'inferior-python-mode-hook 'my-optimize-inferior-python-mode)

#+END_SRC

#+RESULTS:
| my-optimize-inferior-python-mode |

* video-org-sync

#+BEGIN_SRC emacs-lisp
(use-package videorg
  :load-path "~/code/jpjagt/videorg"
  :custom
  (videorg-python-script "/Users/jeroen/code/jpjagt/videorg/videorg.py")
  (videorg-video-folder "/Users/jeroen/video")
  (videorg-org-file (expand-file-name "20240711115118-videos.org" org-roam-directory))
  :bind
  ("C-c v s" . videorg-sync))
#+END_SRC

#+RESULTS:
: videorg-sync

* playground

#+BEGIN_SRC emacs-lisp
(use-package playground
  :straight t)
#+END_SRC

#+RESULTS:

* spotify

** smudge

#+BEGIN_SRC emacs-lisp
(use-package smudge
  :straight t
  :bind-keymap ("C-c ." . smudge-command-map)
  :config
  (setq smudge-oauth2-client-secret spotify-client-secret
        smudge-oauth2-client-id spotify-client-id))
#+END_SRC

#+RESULTS:
| lambda | nil | (interactive) | (use-package-autoload-keymap 'smudge-command-map 'smudge nil) |

** counsel-spotify

#+BEGIN_SRC emacs-lisp
(use-package counsel-spotify
  :straight (:host github :repo "Lautaro-Garcia/counsel-spotify")
  :config
  (setq counsel-spotify-client-id spotify-client-id
        counsel-spotify-client-secret spotify-client-secret))
#+END_SRC

#+RESULTS:
: t
